---
  title: "Proyecto1 : Explorando datos sobre migrantes venezolanos en Colombia"
subtitle: "Facultad de Economía, Universidad de los Andes"
author: "Camila Caraballo, Laura Rivera y Javier Amaya Nieto"
date: "2025-10-31"
output: html_document
---

# Setup del ambiente

```{r, include=FALSE}
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")

# Cargando los paquetes usando pacman
pacman::p_load(
  
  # A) Manipulación, limpieza y visualización de datos
  tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
  forcats,      # Herramientas para trabajar con variables categóricas (factores).
  tibble,       # Implementación moderna de data.frames.
  janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
  lubridate,    # Manejo avanzado de fechas y horas.
  skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
  stringi,      # Manipulación robusta de texto (strings).
  scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
  openxlsx,     # Guardar excel
  writexl,      # Guardar excel

  # B) Modelado y análisis estadístico/econométrico
  fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
  plm,          # Modelos econométricos para datos de panel.
  AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
  lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
  sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
  survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).

  # C) Importación, exportación y generación de reportes
  haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
  readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
  stargazer,    # Creación de tablas de regresión con formato de publicación.
  knitr         # Generación de reportes dinámicos.
)



```

# PARTE 0: Situación

Su grupo de trabajo hace parte de un equipo técnico que apoya a una alcaldía en un programa de mejora de la calidad de vida de hogares venezolanos. La alcaldía quiere mejorar la focalización de su respuesta en vivienda y servicios básicos, pero no sabe qué factores son los más importantes para idenficar condiciones de vida deficientes.

 a) Ajustes iniciales

-   Designando rutas de trabajo y carga de datos: en este paso se puede revisar rapidamente la base de hogares y se carga la base de personas debido a que se usarán algunas variable de esta última para construir unas variables de la base de hogares que será el foco de nuestro trabajo.

```{r}
# Rutas y datos iniciales
xlsx_path <- "data/2025 JNA VP.xlsx"
hogares <- read_excel(xlsx_path, sheet = "Hogares") %>% clean_names()
personas <- read_excel(xlsx_path, sheet = "Personas") %>% clean_names()
```

-   Estandarizar nombres (mayúsculas/acentos) en intro4 e intro5: en este paso ajustamos los nombres de departamento y municipio para mejorar la presentación de los datos de aquí en adelante. Y también se hace un proceso de estandarización usando clean:names() de janitor.

```{r}
# Cambiar nombres y estandarizar
data_hogares <- hogares %>%
   rename(
    DPNOM = intro4,  # Departamento
    MPIO  = intro5   # Municipio
  ) %>%
  mutate(
    DPNOM = DPNOM %>%
      str_to_lower() %>%
      str_trim() %>%
      stri_trans_general("Latin-ASCII") %>%
      str_to_title(),
    
    MPIO = MPIO %>%
      str_to_lower() %>%
      str_trim() %>%
      stri_trans_general("Latin-ASCII") %>%
      str_to_title()
  ) %>% 
  clean_names()

```

b) Selección de la ciudad

Considerando los requisitos del taller y la pregunta de indagación consignada en la sección *Parte 1.a*, que propone comparar las carencias en el acceso a servicios públicos entre hogares migrantes según su nivel de vulnerabilidad, esta sección explica la lógica utilizada para seleccionar una ciudad específica.

En el marco de un programa de mejora de la calidad de vida de hogares venezolanos —en el que nuestro equipo debe apoyar a la alcaldía de una de estos municipios— se decidió identificar la ciudad con la menor tasa de intención de migración a seis meses. Se parte de la premisa de que una población con baja movilidad ofrece un entorno más estable y predecible, lo que representa una ventaja estratégica para diseñar e implementar políticas públicas de largo plazo que fortalezcan la respuesta local en vivienda y servicios básicos.

Asimismo, se detalla el proceso de depuración de datos que permitió construir la variable de intención de movimiento y migración (**int_mov2**). Para ello, se recodificó la variable categórica *demo22* (intención de migración de alguno de los miembros del hogar en los siguientes seis meses) en una nueva variable binaria, **int_mov2**. Se asignó el valor **1** a las respuestas que indicaban planes de migración —ya fuera dentro de Colombia (cambio de municipio o departamento) o fuera del país— y el valor **0** a aquellas sin intención de desplazamiento.

```{r}

# convirtiendo texto categórico a factor
data_hogares <- data_hogares %>% mutate(across(where(is.character), as.factor))

# Creando la variable de intención de movimiento de ciudad
data_hogares <- data_hogares %>%
  mutate(
      int_mov2 = case_when(
      # Condiciones por las que se responde Sí=1
      str_detect(demo22, regex("^No sabe", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, irnos a otro país (diferente a Venezuela)", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, irnos a Venezuela", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, nos vamos a cambiar a otro departamento al interior de Colombia", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, nos vamos a cambiar de municipio pero en el mismo departamento actual", ignore_case = TRUE)) ~ 1L,

      # Condición de lo contrario 
      TRUE ~ 0L
    )
  )
```

Intención de migración

Esta sección presenta, como eje central, los municipios con menor intención de movilidad, complementados con aquellos de mayor intención y las principales razones de desplazamiento, buscando asegurar la coherencia de los hallazgos.

```{r}
# Preparación de datos
top10_muni_menor <- data_hogares %>%
  group_by(mpio) %>%
  summarise(
    n_encuestas = n(),  
    tasa_intencion = mean(int_mov2, na.rm = TRUE)
  ) %>%
  arrange(tasa_intencion) %>%
  slice_head(n = 10) %>%
  mutate(mpio = forcats::fct_rev(forcats::fct_reorder(mpio, tasa_intencion)))

# Gráfico1
# Definiendo colores para mostrar enfasis
color_resalte <- "#e41a1c" 
color_general <- "#003366" 

# Grafico
grafico1 <- ggplot(top10_muni_menor, aes(x = mpio, y = tasa_intencion)) +
  geom_col(aes(fill = ifelse(mpio == first(mpio), color_resalte, color_general)), alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(tasa_intencion, accuracy = 0.1)),
    hjust = -0.1,
    size = 3.5,
    color = "black"
  ) +
  coord_flip(clip = "off") +
  labs(
    title = "Top 10 municipios con menor intención de movilidad",
    subtitle = "Cartagena de Indias destaca por la menor proporción de hogares",
    x = "Municipio",
    y = "Proporción de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    legend.position = "none"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_identity()

print(grafico1)

# Guardando el gráfico
ggsave("results/grafico1.png", 
       plot = grafico1, width = 12, height = 6, dpi = 300)
```

De esta manera, se puede observar que la ciudad con una menor proporción de hogares con intención de movilidad o migración fuera de la ciudad donde residen actualmente es **Cartagena de Indias,** y que será el foco geográfico seleccionado para este análisis.Ahora presentaremos análisis complementarios de esta variable, emepezando por las ciudades con mayor intención de movilida.

```{r}

# Preparando los datos
tasas_muni <- data_hogares %>%
  group_by(mpio) %>%
 summarise(
   n = n(),
   tasa_intencion = mean(int_mov2, na.rm = TRUE)
 ) %>%
 arrange(tasa_intencion)

# TOP 10 de mayor a menor intención.
top10_muni_mayor <- tasas_muni %>%
  arrange(desc(tasa_intencion)) %>%  
  slice_head(n = 10) %>%             
  mutate(mpio = forcats::fct_reorder(mpio, tasa_intencion))

# Grafico
color_barras <- "#003366"  

grafico2 <- ggplot(top10_muni_mayor, aes(x = mpio, y = tasa_intencion)) +
  geom_col(fill = color_barras, alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(tasa_intencion, accuracy = 0.1)),
    hjust = -0.1,
    size = 3.5,
    color = "black"
  ) +
  coord_flip(clip = "off") +
  labs(
    title = "Top 10 municipios con mayor intención de movilidad",
    x = "Municipio",
    y = "Proporción de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  ) +
  scale_y_continuous(labels = scales::percent)

print(grafico2)

# Guardando el gráfico
ggsave("results/grafico2.png", 
       plot = grafico2, width = 12, height = 6, dpi = 300)

```

En esta parte del análisis descriptivo llaman la atención varios municipios que, por su localización, pueden considerarse de **frontera o cercanos a zonas de tránsito migratorio** —como *Pasto, Arauca, Riohacha y Maicao*— los cuales presentan proporciones destacadas de hogares con intención de mudarse. Asimismo, aparecen **ciudades intermedias y grandes urbes** como *Bogotá, Soacha, Barranquilla, Medellín y Pereira*, que podrían funcionar como **destinos de llegada temporal** para migrantes venezolanos, en los que se establecen inicialmente con el fin de trabajar y reunir recursos que les permitan posteriormente desplazarse hacia un segundo destino. Estos hallazgos muestran consistencia con los resultados

Este patrón es consistente con las dinámicas migratorias documentadas en Colombia: los municipios de frontera suelen concentrar población migrante en tránsito, mientras que las grandes ciudades funcionan como polos de atracción por sus oportunidades laborales y por la existencia de redes de apoyo. La presencia simultánea de ambos tipos de municipios en los resultados refuerza la validez de este análisis inicial y aporta coherencia a la elección de **Cartagena de Indias** como ciudad foco para responder la pregunta planteada. Ahora vamos a presentar las razón principal por la cual los hogares quieren mudarse fuera de la ciudad donde residen actualmente y que proporciona una visión más completa de esta característica de intención de movilidad de los migrantes.

```{r}
### Razones principales porque los hogares se quieren mudar

# Seleccionar las variables
razones <- data_hogares %>%
  dplyr::select(
    proteccion1006_v_ctima_de_violencia_amenazas,
    proteccion1006_temor_por_la_situaci_n_general,
    proteccion1006_falta_de_empleo_bajos_ingres,
    proteccion1006_falta_de_acceso_a_alimentos,
    proteccion1006_falta_de_acceso_a_servicios_m,
    proteccion1006_falta_de_acceso_a_educaci_n,
    proteccion1006_desastres_naturales,
    proteccion1006_reunificaci_n_familiar,
    proteccion1006_no_sabe
  )

# Calculando las proporciones
frecuencias <- razones %>%
  summarise(across(everything(), ~ mean(.x, na.rm = TRUE))) %>%
  pivot_longer(cols = everything(),
               names_to = "razon",
               values_to = "proporcion")

# Diccionario 
dicc <- tibble(
  razon = c(
    "proteccion1006_v_ctima_de_violencia_amenazas",
    "proteccion1006_temor_por_la_situaci_n_general",
    "proteccion1006_falta_de_empleo_bajos_ingres",
    "proteccion1006_falta_de_acceso_a_alimentos",
    "proteccion1006_falta_de_acceso_a_servicios_m",
    "proteccion1006_falta_de_acceso_a_educaci_n",
    "proteccion1006_desastres_naturales",
    "proteccion1006_reunificaci_n_familiar",
    "proteccion1006_no_sabe"
  ),
  razon_label = c(
    "Víctima de violencia/amenazas",
    "Temor por la situación general",
    "Falta de empleo o bajos ingresos",
    "Falta de acceso a alimentos",
    "Falta de acceso a servicios médicos",
    "Falta de acceso a educación",
    "Desastres naturales",
    "Reunificación familiar",
    "No sabe"
  )
)

# Uniendo con el diccionario
frecuencias <- frecuencias %>%
  left_join(dicc, by = "razon") %>%
  mutate(porcentaje = proporcion * 100) %>%
  arrange(desc(porcentaje))

# Definir color
color_barras <- "#003366"

# Gráfico
grafico3 <- ggplot(frecuencias, aes(x = reorder(razon_label, porcentaje), y = porcentaje)) +
  geom_col(fill = color_barras) +
  geom_text(
    aes(label = paste0(round(porcentaje, 1), "%")),
    hjust = -0.1,
    size = 3.5
  ) +
  coord_flip() +
  labs(
    title = "Razones de intención de migrar",
    x = "Razón",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    plot.title = element_text(face = "bold", size = 14)
  ) +
  ylim(0, max(frecuencias$porcentaje) + 5)

print(grafico3)

# Guardar en carpeta results
ggsave("results/grafico3.png",
       plot = grafico3, width = 12, height = 6, dpi = 300)


```

# PARTE 1: Planteamiento de la pregunta de indagación

### a) Pregunta de indagación

Teniendo en cuenta los resultados presentados en la **PARTE 0\* Este trabajo busca responder la siguiente pregunta de investigación:\
**¿Existen diferencias en las carencias de acceso a servicios públicos entre hogares migrantes con distintos niveles de vulnerabilidad en Cartagena de Indias?\*\*

```{r}
# Filtrar Cartagena y migrantes
cartagena_pre <- data_hogares %>%
  filter(mpio == "Cartagena De Indias") 
```

Considerando la pregunta de investigación planteada, en esta sección se presentan los **análisis univariados** que permiten explorar con mayor detalle las variables centrales del estudio:

-   **Variable dependiente (Y):** *Carencia de acceso a servicios públicos*, que sintetiza las condiciones de vivienda en términos de energía electríca, gas, agua, acueducto y alcantarillado, y disposición de residuos.\
-   **Variable independiente (X):** *Score de vulnerabilidad*, construido a partir de cuatro condiciones clave de vulnerabilidad que se describirán por separado para facilitar su comprensión (jefatura femenida, hogar monoparental, antecedentes de violencia)

El objetivo de este apartado es caracterizar de manera individual estas variables, identificando su distribución y principales patrones, como paso previo al análisis bivariado que permitirá evaluar la relación entre ellas.

### b) Creación de variable dependiente

Se construye la variable *servicios* que mide la cantidad de servicios básicos de los que carece la vivienda y se construye a partir de las variables (electricidad, gas, alcantallirado, acueducto y recolección de basuras). Por cada servicio que hace falta en el hogar se cuenta como 1 y si carece de todos entonces cuenta como 5

```{r}
cartagena_pre <- cartagena_pre %>%
  mutate(servicios = 
           alojamiento4_alojamiento4_energia +
           alojamiento4_alojamiento4_gas +
           alojamiento4_alojamiento4_alcantarillado +
           alojamiento4_alojamiento4_acueducto +
           alojamiento4_alojamiento4_recoleccion)
```

### c) Creación de variables independientes

Para intentar análizar de forma diferencial las diferencias en las carencias de acceso a servicios públicos (variable dependiente), se construyó un **índice de vulnerabilidad** a nivel de hogar que sintetiza cuatro condiciones estructurales asociadas a un mayor riesgo social. Estas condiciones, consideradas de manera individual y en conjunto, permiten caracterizar la situación de vulnerabilidad de los hogares migrantes en Cartagena de Indias. Las variables consideradas son:

1.  **Jefatura femenina del hogar**: identifica si la persona cabeza de hogar es mujer.\
2.  **Hogar monoparental**: determina si el hogar está conformado por un padre o madre sin cónyuge y con hijos, o si incluye un “Papá/Mamá” con estado civil soltero, separado, divorciado o viudo.\
3.  **Presencia de personas con discapacidad**: señala si al menos un miembro del hogar reporta alguna limitación o barrera física.\
4.  **Antecedentes de violencia o amenazas**: registra si algún miembro del hogar ha sido víctima de violencia o amenazas.

A partir de estas cuatro dimensiones se calculó la variable de interés principal, el **índice de vulnerabilidad**, definido como un **puntaje aditivo de 0 a 4** que suma un punto por cada condición cumplida. Este índice ofrece una medida sintética de la vulnerabilidad de los hogares y servirá como **variable independiente (X)** en los análisis posteriores.

En los siguientes apartados se describe, paso a paso, el procedimiento para identificar cada una de las cuatro condiciones de vulnerabilidad, con sus respectivos resúmenes para Cartagena, el resto del país y el total nacional, antes de integrar la información en el índice final.

1) Jefatura femenina del hogar

```{r}
# 1. Preparar variable de sexo del jefe
hogares_out <- data_hogares %>%
  mutate(
    head_sex = if_else(demo3 == "Sí", demo2, demo4),
    head_female = if_else(head_sex == "Mujer", 1L, 0L)
  )

# 2. Resumen por región
resumen_jefatura <- bind_rows(
  # Cartagena vs Resto país
  hogares_out %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      con_jefatura_femenina = sum(head_female == 1, na.rm = TRUE),
      pct_jefatura_femenina = round(mean(coalesce(as.integer(head_female), 0L) == 1) * 100, 2),
      .groups = "drop"
    ),
  # Total país
  hogares_out %>%
    summarise(
      region = "Total país",
      hogares = n(),
      con_jefatura_femenina = sum(head_female == 1, na.rm = TRUE),
      pct_jefatura_femenina = round(mean(coalesce(as.integer(head_female), 0L) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))


# 3. Crear tabla HTML con formato “aer”
tabla1 <- resumen_jefatura %>%
  kable(
    format = "html",
    caption = "Jefatura femenina por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Con jefatura femenina", "% Jefatura femenina")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  # Encabezado personalizado

# 4. Guardar tabla como HTML
save_kable(tabla1, "results/tabla1.html")


```

2) Hogar monoparental

```{r}
# 1. Estados civiles 
single_status <- c("Soltero/a", "Separado/a", "Divorciado/a", "Viudo/a")

# 2. Agregado por hogar desde la base de Personas
per_hh <- personas %>%
  group_by(id_hogar) %>%
  summarise(
    has_conyuge = any(miembros4 == "Conyugue", na.rm = TRUE),
    has_hijo    = any(miembros4 == "Hijo/a", na.rm = TRUE),
    papa_mama_single = any(miembros4 == "Papá/Mamá" & miembros20f %in% single_status, na.rm = TRUE),
    .groups = "drop"
  )

# 3. Información de hogares 
hog_min <- data_hogares %>%
  select(id_hogar, demo3, mpio) %>%
  mutate(respondent_is_head = demo3 == "Sí")

# 4. Identificar hogares monoparentales
hog_single <- hog_min %>%
  left_join(per_hh, by = "id_hogar") %>%
  mutate(
    via_A = respondent_is_head & has_hijo & !has_conyuge,
    via_B = !respondent_is_head & papa_mama_single,
    single_parent_relaxed = as.integer(via_A | via_B)
  )

# 5. Resumen por región
resumen_single <- bind_rows(
  hog_single %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_single_parent = sum(single_parent_relaxed == 1, na.rm = TRUE),
      pct_single_parent = round(mean(coalesce(as.integer(single_parent_relaxed), 0L) == 1) * 100, 2),
      .groups = "drop"
    ),
  hog_single %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_single_parent = sum(single_parent_relaxed == 1, na.rm = TRUE),
      pct_single_parent = round(mean(coalesce(as.integer(single_parent_relaxed), 0L) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 6. Crear tabla HTML con formato “aer”
tabla2 <- resumen_single %>%
  kable(
    format = "html",
    caption = "Hogares monoparentales por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares monoparentales", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  

# 7. Guardar tabla
save_kable(tabla2, "results/tabla2.html")

```

3) Personas con discapacidad

```{r}
# 1) Identificando personas con discapacidad
personas_disc <- personas %>%
  mutate(
    has_disability_person = as.integer(
      (salud12_barreras_salud_fisica == TRUE) |
        (miembros27_barre_discp == 1)
    )
  ) %>%
  select(id_hogar, id_persona, salud12_barreras_salud_fisica,
         miembros27_barre_discp, has_disability_person)

# 2) Agregado a nivel hogar
hog_disc <- personas_disc %>%
  group_by(id_hogar) %>%
  summarise(
    household_has_disability = as.integer(any(has_disability_person == 1, na.rm = TRUE)),
    .groups = "drop"
  )

# 3) Unir con hogares y agregar región
hogares_disability <- data_hogares %>%
  left_join(hog_disc, by = "id_hogar")

# 4) Resumen por región
resumen_disability <- bind_rows(
  hogares_disability %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_hh_con_discapacidad = sum(household_has_disability == 1, na.rm = TRUE),
      pct_hh_con_discapacidad = round(mean(replace(household_has_disability, is.na(household_has_disability), 0) == 1) * 100, 2),
      .groups = "drop"
    ),
  hogares_disability %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_hh_con_discapacidad = sum(household_has_disability == 1, na.rm = TRUE),
      pct_hh_con_discapacidad = round(mean(replace(household_has_disability, is.na(household_has_disability), 0) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 5) Crear tabla HTML con formato “aer”
tabla3 <- resumen_disability %>%
  kable(
    format = "html",
    caption = "Hogares con alguna persona con discapacidad por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares con discapacidad", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50") 

# 6) Guardar tabla como HTML
save_kable(tabla3, "results/tabla3.html")

```

4) Antecedentes de violencia o amenazas
```{r}
# 1) Identificando hogares con violencia para alguno de sus miembros
hogares_violencia_amenazas <- data_hogares %>%
  mutate(
    household_survivor_violence = if_else(
      proteccion1006_v_ctima_de_violencia_amenazas == 1, 1L, 0L, missing = 0L
    )
  )

# 2) Resumen por región
resumen_violencia_amenazas <- bind_rows(
  hogares_violencia_amenazas %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_hh_con_violencia = sum(household_survivor_violence == 1, na.rm = TRUE),
      pct_hh_con_violencia = round(mean(household_survivor_violence == 1, na.rm = TRUE) * 100, 2),
      .groups = "drop"
    ),
  hogares_violencia_amenazas %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_hh_con_violencia = sum(household_survivor_violence == 1, na.rm = TRUE),
      pct_hh_con_violencia = round(mean(household_survivor_violence == 1, na.rm = TRUE) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 3) Crear tabla HTML con formato “aer”
tabla4 <- resumen_violencia_amenazas %>%
  kable(
    format = "html",
    caption = "Hogares con algún miembro víctima de violencia o amenazas por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares con violencia", "% Hogares con violencia")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  

# 4) Guardar tabla como HTML
save_kable(tabla4, "results/tabla4.html")
```


5) Índice de vulnerabilidad

Finalmente, el índice de vulnerabilidad es un puntaje aditivo (0–4) que suma cuatro puntos: (1) jefatura del hogar femenina; (2) hogar mono-parental, definido como jefe/a sin cónyuge y con hijos, o presencia de “Papá/Mamá” con estado civil soltero/separado/divorciado/viudo; (3) al menos una persona con discapacidad en el hogar; y (4) antecedente de violencia contra miembros del hogar (proteccion1006_v_ctima_de_violencia_amenazas). El código incluye una comparación de Cartagéna y el país.

```{r}
# 1) Construcción del score de vulnerabilidad
hogares_vulnerabilidad <- hogares_out %>%
  select(id_hogar, mpio, head_female, f_exp_hog) %>%
  left_join(hog_single %>% select(id_hogar, single_parent_relaxed), by = "id_hogar") %>%
  left_join(hogares_disability %>% select(id_hogar, household_has_disability), by = "id_hogar") %>%
  left_join(hogares_violencia_amenazas %>% select(id_hogar, household_survivor_violence), by = "id_hogar") %>%
  mutate(
    head_female                  = coalesce(as.integer(head_female), 0L),
    single_parent_relaxed        = coalesce(as.integer(single_parent_relaxed), 0L),
    household_has_disability     = coalesce(as.integer(household_has_disability), 0L),
    household_survivor_violence = coalesce(as.integer(household_survivor_violence), 0L),
    vulnerability_score = head_female +
                          single_parent_relaxed +
                          household_has_disability +
                          household_survivor_violence
  )

# 2a) Tabla “larga”: conteos y porcentajes por score y región
resumen_score <- bind_rows(
  hogares_vulnerabilidad %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    count(region, vulnerability_score, name = "n") %>%
    group_by(region) %>% mutate(pct = round(100 * n / sum(n), 2)) %>% ungroup(),
  hogares_vulnerabilidad %>%
    count(vulnerability_score, name = "n") %>%
    mutate(region = "Total país") %>%
    group_by(region) %>% mutate(pct = round(100 * n / sum(n), 2)) %>% ungroup()
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")),
          vulnerability_score)

# Tabla larga HTML
tabla5 <- resumen_score %>%
  kable(
    format = "html",
    caption = "Distribución del índice de vulnerabilidad por score y región (tabla larga)",
    digits = 2,
    col.names = c("Región", "Score de vulnerabilidad", "N", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

# Guardar tabla larga
save_kable(tabla5, "results/tabla5.html")

# 2b) Tabla “ancha”: porcentajes por columnas 0–4
tabla_score_pct <- resumen_score %>%
  select(region, vulnerability_score, pct) %>%
  pivot_wider(names_from = vulnerability_score, values_from = pct, values_fill = 0) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# Tabla ancha HTML
tabla6 <- tabla_score_pct %>%
  kable(
    format = "html",
    caption = "Distribución del índice de vulnerabilidad por región (tabla ancha, %)",
    digits = 2
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

# Guardar tabla ancha
save_kable(tabla6, "results/tabla6.html")

```


### d) Integración de variables en una base

Ahora vamos a integrar las variables necesarias para los análisis de las siguientes secciones:

```{r}

# copiando el DF de variables definitivas por hogar pero solo para Cartagena - VARIABLE DEPENDIENTE
cartagena_dep <- cartagena_pre %>% 
                  dplyr::select(id_hogar,
                                servicios, 
                                alojamiento4_alojamiento4_energia, 
                                alojamiento4_alojamiento4_gas,
                                alojamiento4_alojamiento4_alcantarillado,
                                alojamiento4_alojamiento4_acueducto,
                                alojamiento4_alojamiento4_recoleccion)


# copiando el DF de variables definitivas por hogar pero solo para Cartagena - VARIABLE INDEPENDIENTE
cartagena_ind <- hogares_vulnerabilidad %>%
                  filter(mpio=="Cartagena De Indias") %>% 
                  dplyr::select(id_hogar, 
                                head_female, 
                                single_parent_relaxed, 
                                household_has_disability,
                                household_survivor_violence, 
                                vulnerability_score,
                                f_exp_hog)


# OTRAS VARIABLES
# se deja abierta por si es requerido


# Uniendo las bases de datos
cartagena <- left_join(cartagena_dep, cartagena_ind, by = "id_hogar")

```

# PARTE 2: Análisis univariado

Antes de cruzar variables, se debe entender cada variable por sí sola: su codificación, distribución, faltantes y posibles errores. Esto asegura que las comparaciones bivariadas no estén sesgadas pordatos mal definidos. ¿Qué abordar para cada variable? Tipo y codificación: ¿numérica, categórica (nominal/ordinal),fecha, texto? ¿Binarias están en 0/1?

### a) Variable dependiente: Servicios

-   La variable servicios es númerica con 163 observaciones
-   Hay hogares en la base que cuentan con todos los servicios
-   Los valores de servicios van de 0 a 4, ningun hogar tiene los 5 servicios
-   Todos los hogares tienen un dato, es decir, no se encuentran NA

```{r}
# 1. Ver estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$servicios)))

# 2. Resumen estadístico
resumen <- data.frame(
  estadistico = names(summary(cartagena$servicios)),
  valor = as.vector(summary(cartagena$servicios))
)

# 3. Rango observado
rango <- data.frame(rango = range(cartagena$servicios, na.rm = TRUE))

# 4. Contar valores NA
num_na <- data.frame(NA_count = sum(is.na(cartagena$servicios)))

# Exportar todo en un Excel con varias hojas
write_xlsx(
  list(
    Estructura  = estructura,
    Resumen     = resumen,
    Rango       = rango,
    Valores_NA  = num_na,
    Frecuencias = frecuencias
  ),
  "results/tabla1.xlsx"
)


# Chequear si hay valores fuera de 0–5
cartagena %>%
  filter(!is.na(servicios) & (servicios < 0 | servicios > 5))
```

Se aplicó el factor de expansión de hogares (F_EXP_hog) para calcular la distribución, con el fin de garantizar que los resultados reflejen la distribución poblacional y no solo la muestra encuestada. Esto significa que cada observación representa un número mayor de hogares en la población, y los totales se obtienen sumando los pesos en lugar de contar registros.

```{r}
# Tipo de variable
str(cartagena$servicios)

# Tabla sin ponderar
tabla_simple_serv <- cartagena %>%
  count(servicios) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    label = as.character(servicios)
  )

# Tabla ponderada con factor de expansión
tabla_pond_serv <- cartagena %>%
  group_by(servicios) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    label = as.character(servicios)
  )

# Comparación sin vs con ponderación
tabla_comp_serv <- bind_rows(tabla_simple_serv, tabla_pond_serv)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp_serv,
  "results/tabla2.xlsx"
)


# Gráfico comparativo
grafico4 <- ggplot(tabla_comp_serv, aes(x = label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.5,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Carencias en servicios básicos en los hogares",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Número de servicios faltantes",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico4)

ggsave("results/grafico4.png",
       plot = grafico4, width = 10, height = 6, dpi = 300)



```

### b) Variables independientes

####1) Jefatura femenina del hogar

La variable head_female es una variable binaria, donde 1 corresponde a jefatura femenina y 0 a jefatura masculina, sin valores faltantes ni atípicos.

Se realiza el análisis de frecuencias sin ponderación que se evidencia que el 61,2% de los hogares tienen jefatura femenina frente al 38,8% con jefatura masculina. Sin embargo, al realizar las frecuencias aplicando el factor de expansión, la distribución se invierte: el 57,2% de los hogares en el país presentan jefatura masculina, mientras que el 42,8% tienen jefatura femenina.Estos resultados reflejan el cambio que se tiene al aplicar la variable de expansión como pesos muestrales.

```{r}
# 1. Tipo de variable (estructura)
estructura <- data.frame(estructura = capture.output(str(cartagena$head_female)))

# 2. Distribución (frecuencias sin ponderar)
tabla_simple <- as.data.frame(table(cartagena$head_female, useNA = "ifany"))
colnames(tabla_simple) <- c("Valor", "Frecuencia")

# 3. Proporciones 
prop_simple <- round(prop.table(table(cartagena$head_female, useNA = "ifany")) * 100, 1)
prop_simple <- data.frame(Valor = names(prop_simple), Proporcion = as.vector(prop_simple))

# 4. Datos NAs
num_na <- data.frame(
  NA_count = sum(is.na(cartagena$head_female)),
  NA_pct   = round(mean(is.na(cartagena$head_female)) * 100, 2)
)

# 5. Valores únicos
valores_unicos <- data.frame(Valores_unicos = unique(cartagena$head_female))

# Exportar en Excel
write_xlsx(
  list(
    Estructura   = estructura,
    Frecuencias  = tabla_simple,
    Proporciones = prop_simple,
    Valores_NA   = num_na,
    Valores_unicos = valores_unicos
  ),
  "results/tabla3.xlsx"
)

# Tabla sin ponderar
tabla_simple_df <- cartagena %>%
  count(head_female) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    head_female_label = case_when(
      head_female == 1 ~ "Mujer",
      head_female == 0 ~ "Hombre",
      TRUE ~ "No sabe/NA"
    )
  )

# Tabla con ponderaración
tabla_pond <- cartagena %>%
  group_by(head_female) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    head_female_label = case_when(
      head_female == 1 ~ "Mujer",
      head_female == 0 ~ "Hombre",
      TRUE ~ "No sabe/NA"
    )
  )

print(tabla_pond)

# Gráfico con ponderación y sin 
tabla_comp <- bind_rows(tabla_simple_df, tabla_pond)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp,
  "results/tabla4.xlsx"
)

# Gráfico
grafico6 <- ggplot(tabla_comp, aes(x = head_female_label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.5, size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Distribución de jefatura del hogar",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Sexo del jefe/a",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico6)

ggsave("results/grafico5.png",
       plot = grafico6, width = 10, height = 6, dpi = 300)

```

####2) Hogar monoparental:

De la variable single_parent_relaxed creada anteriormente, se puede decir que no se identificaron valores faltantes en la variable y los únicos valores posibles fueron 0 y 1. Ahora bien a continuación se evidencia que esta variable sin ponderar representa un 26,6 % de los hogares están conformados por un solo adulto responsable de hijos, mientras que el 73,4 % restante cuenta con dos o más adultos.

Al ponderar con el factor de expansión de los hogares, la proporción de hogares con un solo adulto responsable baja a 19 %, lo que refleja la representatividad de estos hogares en la población. Esta información es importante para identificar posibles necesidades de apoyo social o programas dirigidos a hogares con un solo adulto a cargo.

```{r}
# 1. Tipo de variable (estructura)
estructura_sp <- data.frame(estructura = capture.output(str(cartagena$single_parent_relaxed)))

# 2. Distribución (frecuencias sin ponderar)
tabla_simple_sp <- as.data.frame(table(cartagena$single_parent_relaxed, useNA = "ifany"))
colnames(tabla_simple_sp) <- c("Valor", "Frecuencia")

# 3. Proporciones
prop_simple_sp <- round(prop.table(table(cartagena$single_parent_relaxed, useNA = "ifany")) * 100, 1)
prop_simple_sp <- data.frame(Valor = names(prop_simple_sp), Proporcion = as.vector(prop_simple_sp))

# 4. Datos NAs
num_na_sp <- data.frame(
  NA_count = sum(is.na(cartagena$single_parent_relaxed)),
  NA_pct   = round(mean(is.na(cartagena$single_parent_relaxed)) * 100, 2)
)

# 5. Valores únicos
valores_unicos_sp <- data.frame(Valores_unicos = unique(cartagena$single_parent_relaxed))

# Exportar en Excel 
write_xlsx(
  list(
    Estructura     = estructura_sp,
    Frecuencias    = tabla_simple_sp,
    Proporciones   = prop_simple_sp,
    Valores_NA     = num_na_sp,
    Valores_unicos = valores_unicos_sp
  ),
  "results/tabla5.xlsx"
)


# Tabla sin ponderar
tabla_simple_df_sp <- cartagena %>%
  count(single_parent_relaxed) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    label = case_when(
      single_parent_relaxed == 1 ~ "Solo un adulto con hijos",
      single_parent_relaxed == 0 ~ "Dos o más adultos",
      TRUE ~ "No sabe/NA"
    )
  )


# Tabla ponderada con factor de expansión
tabla_pond_sp <- cartagena %>%
  group_by(single_parent_relaxed) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    label = case_when(
      single_parent_relaxed == 1 ~ "Solo un adulto con hijos",
      single_parent_relaxed == 0 ~ "Dos o más adultos",
      TRUE ~ "No sabe/NA"
    )
  )

print(tabla_pond_sp)

# Tabla (sin ponderar vs ponderado)
tabla_comp_sp <- bind_rows(tabla_simple_df_sp, tabla_pond_sp)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp_sp,
  "results/tabla6.xlsx"
)

# Gráfico comparativo (sin ponderar vs ponderado)
grafico8 <- ggplot(tabla_comp_sp, aes(x = label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.5, size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Distribución de hogares según número de adultos responsables",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Tipo de hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico8)

ggsave("results/grafico7.png",
       plot = grafico8, width = 10, height = 6, dpi = 300)

```

####3) Personas con discapacidad

La variable household_has_disability, que indica si al menos una persona en el hogar presenta alguna discapacidad. La variable es de tipo entero (int), con valores 0 (sin discapacidad) y 1 (al menos un miembro con discapacidad) y así sucesivamente. En el análisis sin ponderar, se observaron 3.097 hogares sin discapacidad y 28 con al menos un miembro con discapacidad, lo que representa el 99,1 % y 0,9 % respectivamente. No se encontraron valores faltantes en la variable.

Luego, se incorporó el factor de expansión f_exp_hog proveniente de la base de hogares, lo que evidencia que la gran mayoría de los hogares no cuenta con miembros con discapacidad y que solo una proporción muy pequeña presenta al menos un miembro con discapacidad

```{r}
# 1. Tipo de variable (estructura)
estructura_dis <- data.frame(estructura = capture.output(str(cartagena$household_has_disability)))

# 2. Frecuencias sin ponderar
tabla_simple_dis <- as.data.frame(table(cartagena$household_has_disability, useNA = "ifany"))
colnames(tabla_simple_dis) <- c("Valor", "Frecuencia")

# 3. Proporciones
prop_simple_dis <- round(prop.table(table(cartagena$household_has_disability, useNA = "ifany")) * 100, 1)
prop_simple_dis <- data.frame(Valor = names(prop_simple_dis), Proporcion = as.vector(prop_simple_dis))

# 4. Datos NAs
num_na_dis <- data.frame(
  NA_count = sum(is.na(cartagena$household_has_disability)),
  NA_pct   = round(mean(is.na(cartagena$household_has_disability)) * 100, 2)
)

# 5. Valores únicos
valores_unicos_dis <- data.frame(Valores_unicos = unique(cartagena$household_has_disability))

# Exportar Excel
write_xlsx(
  list(
    Estructura     = estructura_dis,
    Frecuencias    = tabla_simple_dis,
    Proporciones   = prop_simple_dis,
    Valores_NA     = num_na_dis,
    Valores_unicos = valores_unicos_dis
  ),
  "results/tabla7.xlsx"
)


# Tabla sin ponderar
tabla_simple_df_dis <- cartagena %>%
  count(household_has_disability) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    label = case_when(
      household_has_disability == 1 ~ "Hogar con discapacidad",
      household_has_disability == 0 ~ "Sin discapacidad",
      TRUE ~ "No sabe/NA"
    )
  )

# Tabla ponderada con factor de expansión
tabla_pond_dis <- cartagena %>%
  group_by(household_has_disability) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    label = case_when(
      household_has_disability == 1 ~ "Hogar con discapacidad",
      household_has_disability == 0 ~ "Sin discapacidad",
      TRUE ~ "No sabe/NA"
    )
  )

# Tabla comparativo 
tabla_comp_dis <- bind_rows(tabla_simple_df_dis, tabla_pond_dis)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp_dis,
  "results/tabla8.xlsx"
)

# Gráfico comparativo 
grafico9 <- ggplot(tabla_comp_dis, aes(x = label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), position = position_dodge(width = 0.9), vjust = -0.5, size = 3.5) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Distribución de hogares según presencia de discapacidad",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Tipo de hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico9)
ggsave("results/grafico8.png", plot = grafico9, width = 10, height = 6, dpi = 300)

```

####4) Antecedentes de violencia o amenazas:

La variable *household_survivor_violence* indica si el hogar sufrió violencia. Siendo esta de tipo entero con valores 1 y 0, el cual toma el valor de 1 si sufrió algún tipo de violencia. En el análisis sin ponderar, se observan 151 hogares sin violencia, y 12 con violencia, lo que representa el 92,6% y 7,4% respectivamente. En esta variable no se registran valores faltantes.

Por otra parte, aplicando el factor de expansión, la relación se mantuvo bastante similar, revelando así que la mayoría de estos hogares no han enfrentado situaciones de violencia.

```{r}
# 1. Tipo de variable (estructura)
estructura_vio <- data.frame(estructura = capture.output(str(cartagena$household_survivor_violence)))

# 2. Frecuencias sin ponderar
tabla_simple_vio <- as.data.frame(table(cartagena$household_survivor_violence, useNA = "ifany"))
colnames(tabla_simple_vio) <- c("Valor", "Frecuencia")

# 3. Proporciones
prop_simple_vio <- round(prop.table(table(cartagena$household_survivor_violence, useNA = "ifany")) * 100, 1)
prop_simple_vio <- data.frame(Valor = names(prop_simple_vio), Proporcion = as.vector(prop_simple_vio))

# 4. Datos NAs
num_na_vio <- data.frame(
  NA_count = sum(is.na(cartagena$household_survivor_violence)),
  NA_pct   = round(mean(is.na(cartagena$household_survivor_violence)) * 100, 2)
)

# 5. Valores únicos
valores_unicos_vio <- data.frame(Valores_unicos = unique(cartagena$household_survivor_violence))

# Exportar todo en un Excel con varias hojas
write_xlsx(
  list(
    Estructura     = estructura_vio,
    Frecuencias    = tabla_simple_vio,
    Proporciones   = prop_simple_vio,
    Valores_NA     = num_na_vio,
    Valores_unicos = valores_unicos_vio
  ),
  "results/tablas/tabla9.xlsx"
)
# Tabla sin ponderar
tabla_simple_df_vio <- cartagena %>%
  count(household_survivor_violence) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    label = case_when(
      household_survivor_violence == 1 ~ "Víctima de violencia",
      household_survivor_violence == 0 ~ "Sin violencia",
      TRUE ~ "No sabe/NA"
    )
  )

# Tabla ponderada con factor de expansión
tabla_pond_vio <- cartagena %>%
  group_by(household_survivor_violence) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    label = case_when(
      household_survivor_violence == 1 ~ "Víctima de violencia",
      household_survivor_violence == 0 ~ "Sin violencia",
      TRUE ~ "No sabe/NA"
    )
  )


# Tabla comparativo 
tabla_comp_vio <- bind_rows(tabla_simple_df_vio, tabla_pond_vio)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp_vio,
  "results/tablas/tabla10.xlsx"
)

# Gráfico comparativo 
grafico11 <- ggplot(tabla_comp_vio, aes(x = label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), position = position_dodge(width = 0.9), vjust = -0.5, size = 3.5) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Distribución de hogares víctimas de violencia",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Tipo de hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico11)
ggsave("results/figures/grafico9_resultados_antecedente_violencia.png", plot = grafico11, width = 10, height = 6, dpi = 300)
```

#### 5) Índice de vulnerabilidad

Explorando en detalle el índice de vulnerabilidad, definida como una variable categórica de 0 a 4, la cual indica la cantidad de vulnerabilidades con las que cuentan los hogares. Es de tipo entero y no contiene datos faltantes. En general, esta visualización preliminar muestra que en el cálculo ponderado, el 40,3% de los hohares no cuentan con ninguna vulnerabilidad, el 36,4% cuenta con al menos una, el 20,9% cuenta con 2 y un pequeño porcentaje del 2,4% cuenta con las 3.

```{r}
# Se realiza una copia del DF de análisis
cartagena_vul <- cartagena

# 1. Tipo de variable (estructura)
estructura_vul <- data.frame(estructura = capture.output(str(cartagena_vul$vulnerability_score)))

# 2. Frecuencias sin ponderar
tabla_simple_vul <- as.data.frame(table(cartagena_vul$vulnerability_score, useNA = "ifany"))
colnames(tabla_simple_vul) <- c("Valor", "Frecuencia")

# 3. Proporciones 
prop_simple_vul <- round(prop.table(table(cartagena_vul$vulnerability_score, useNA = "ifany")) * 100, 1)
prop_simple_vul <- data.frame(Valor = names(prop_simple_vul), Proporcion = as.vector(prop_simple_vul))

# 4. Datos NAs
num_na_vul <- data.frame(
  NA_count = sum(is.na(cartagena_vul$vulnerability_score)),
  NA_pct   = round(mean(is.na(cartagena_vul$vulnerability_score)) * 100, 2)
)

# 5. Valores únicos
valores_unicos_vul <- data.frame(Valores_unicos = unique(cartagena_vul$vulnerability_score))

# 6. Resumen estadístico
resumen_vul <- data.frame(
  estadistico = names(summary(cartagena_vul$vulnerability_score)),
  valor = as.vector(summary(cartagena_vul$vulnerability_score))
)

# Exportar Excel 
write_xlsx(
  list(
    Estructura       = estructura_vul,
    Frecuencias      = tabla_simple_vul,
    Proporciones     = prop_simple_vul,
    Valores_NA       = num_na_vul,
    Valores_unicos   = valores_unicos_vul,
    Resumen_estadistico = resumen_vul
  ),
  "results/tablas/tabla11.xlsx"
)

# Tabla sin ponderar
tabla_simple_df_vul <- cartagena_vul %>%
  count(vulnerability_score) %>%
  mutate(
    n = as.numeric(n),
    porc = round(100 * n / sum(n), 1),
    tipo = "Sin ponderar",
    label = case_when(
      vulnerability_score == 1 ~ "1",
      vulnerability_score == 2 ~ "2",
      vulnerability_score == 3 ~ "3",
      vulnerability_score == 4 ~ "4",
      TRUE ~ "No vulnerable"
    )
  )


# Tabla ponderada con factor de expansión
tabla_pond_vul <- cartagena_vul %>%
  group_by(vulnerability_score) %>%
  summarise(n = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    tipo = "Ponderado",
    label = case_when(
     vulnerability_score == 1 ~ "1",
      vulnerability_score == 2 ~ "2",
      vulnerability_score == 3 ~ "3",
      vulnerability_score == 4 ~ "4",
      TRUE ~ "No vulnerable"
    )
  )

# Tabla comparativo 
tabla_comp_vul <- bind_rows(tabla_simple_df_vul, tabla_pond_vul)

# Guardar tabla en Excel
write_xlsx(
  tabla_comp_vul,
  "results/tablas/tabla12.xlsx"
)

# Gráfico comparativo 
grafico13 <- ggplot(tabla_comp_vul, aes(x = label, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), position = position_dodge(width = 0.9), vjust = -0.5, size = 3.5) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Distribución de hogares según su vulnerabilidad",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Cantidad de vulnerabilidades",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

print(grafico13)
ggsave("results/figures/grafico10_resultados_score_vulnerability.png", plot = grafico13, width = 10, height = 6, dpi = 300)

```

# PARTE 3: Visualizaciones de exploración según la pregunta de indagación

Empezamos tratando las variable Y como continua y la variable X como categórica para la expliración inicial.

```{r}

# Definir diseño de encuesta con pesos
design <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena)

# Calcular medias por vulnerabilidad con IC95%
tabla_medias_pond2 <- svyby(~servicios, ~vulnerability_score, design, svymean, vartype = c("ci"))

# Gráfico
grafico_pond2 <- ggplot(tabla_medias_pond2, aes(x = as.factor(vulnerability_score), y = servicios)) +
  geom_col(fill = "#003366", alpha = 0.8) +
  geom_errorbar(aes(ymin = ci_l, ymax = ci_u), width = 0.2, color = "#e41a1c") +
  geom_text(aes(label = round(servicios, 2)), vjust = -0.5, size = 3.5, color = "black") +
  labs(
    title = "Media de servicios faltantes según vulnerabilidad",
    subtitle = "Cartagena de Indias – ponderado con factor de expansión",
    x = "Índice de vulnerabilidad (0–4)",
    y = "Promedio ponderado de servicios faltantes", 
    caption = "Nota: Para la construcción del gráfico se usó el factor de expansión para hogares. "
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )

print(grafico_pond2)

```

Es posible que esta estrategia no sea tan adecuada porque es posible que la distribución de la variable de carencia de servicios no siga una distribución normal y esto afecte negativamente la visualización de los datos. De esta manera, se considera quye una opción puede ser revisar la proporción de hogares con carencia de 2 o más servicios (dicotomizar la variable de carencia de servicios) y visualizar esta variable para cada una de las condiciones de vulnerabilidad. Este análisis tiene relevancia ya que es posible que las diferentes condiciones evaluadas no tengan la misma ponderación al analizar la variable latente "vulnerabilidad".

```{r}
# Objeto de diseño de encuesta
design <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena)

# Seleccionando las variables
vars <- c("head_female",
          "single_parent_relaxed",
          "household_has_disability",
          "household_survivor_violence")

# Función: media ponderada de `servicios` por nivel de cada variable (IC95%)
res_list <- map(vars, function(v){
  f <- reformulate(v)                     
  out <- svyby(~servicios, f, design,
               svymean, vartype = c("ci"), na.rm = TRUE, keep.names = FALSE)
  names(out)[names(out) == "servicios"] <- "mean"
  out$var   <- v
  names(out)[names(out) == v] <- "level"   
  out
})

res <- bind_rows(res_list) %>%
  mutate(
    var = case_match(var,
      "head_female"               ~ "Jefatura femenina",
      "single_parent_relaxed"     ~ "Hogar monoparental",
      "household_has_disability"  ~ "Con discapacidad en el hogar",
      "household_survivor_violence" ~ "Antecedente de violencia"
    ),
    level = factor(level, levels = c(0,1), labels = c("No","Sí"))
  )

# Gráfico
g_comp <- ggplot(res, aes(x = level, y = mean)) +
  geom_col(fill = "#003366", alpha = 0.85) +
  geom_errorbar(aes(ymin = ci_l, ymax = ci_u), width = 0.15, color = "#e41a1c") +
  geom_text(aes(label = round(mean, 2)), vjust = -0.6, size = 3.3) +
  facet_wrap(~ var, nrow = 1) +
  labs(
    title = "Carencias de servicios por componentes de vulnerabilidad",
    subtitle = "Cartagena de Indias – promedio ponderado de servicios faltantes (0–5) con IC95%",
    x = NULL,
    y = "Promedio ponderado de servicios faltantes",
    caption = "Ponderado por f_exp_hog. Barras = E[servicios|X], líneas = IC95%."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.caption = element_text(hjust = 0)
  )

print(g_comp)

```

Revisando todas las gráficas previas del bivariado, nos dimos cuenta que estabamos usando la variable de carencia de servicios como continua y al final la codificación que usamos puede que actue más como una variable categórica y por esta razón decidimos hacer una exploración inicial de cada variable poniendo un punto de corte de 2 servicios carentes o más.

```{r}
# Creando una copia del df oringial.
cartagena_tmp <- cartagena %>%
  mutate(falta_mas1 = as.integer(servicios >= 2)) 

# Objeto de diseño de encuesta para usar el factor de expansión
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# función para dar formato
nice_pct <- function(x) sprintf("%.1f%%", 100*x)

# Función para calcular y graficar 
make_prop_plot <- function(var, var_label, file_out, des){
  fml <- reformulate(var)
  out <- svyby(~falta_mas1, fml, des, svymean,
               vartype = c("ci"), na.rm = TRUE, keep.names = FALSE)

  names(out)[names(out) == "falta_mas1"] <- "prop"
  names(out)[names(out) == var] <- "level"

  df <- out %>%
    mutate(
      level = factor(level, levels = c(0,1), labels = c("No","Sí")),
      prop_lab = nice_pct(prop)
    )

  g <- ggplot(df, aes(x = level, y = prop)) +
    geom_col(fill = "#003366", alpha = 0.9) +
    geom_errorbar(aes(ymin = ci_l, ymax = ci_u),
                  width = 0.18, color = "#e41a1c") +
    geom_text(aes(label = prop_lab), vjust = -0.6, size = 3.5) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    labs(
      title = paste0("Hogares con >1 servicio faltante por ", var_label),
      subtitle = "Proporción ponderada (IC95%) – Cartagena de Indias",
      x = var_label,
      y = "Proporción de hogares",
      caption = "Ponderado por f_exp_hog. Indicador: servicios ≥ 2."
    ) +
    theme_minimal(base_size = 12) +
    theme(
      panel.grid = element_blank(),
      plot.caption = element_text(hjust = 0)
    )

  print(g)
}

# Ejecutando la función para cada variable de interés. 
make_prop_plot("head_female",
               "Jefatura femenina",
               "results/figures/prop_mas1_head_female.png",
               des_tmp)

make_prop_plot("single_parent_relaxed",
               "Hogar monoparental",
               "results/figures/prop_mas1_single_parent.png",
               des_tmp)

make_prop_plot("household_has_disability",
               "Con discapacidad en el hogar",
               "results/figures/prop_mas1_disability.png",
               des_tmp)

make_prop_plot("household_survivor_violence",
               "Antecedente de violencia",
               "results/figures/prop_mas1_violence.png",
               des_tmp)


```

```{r}
# preparación de datos
cartagena_tmp <- cartagena %>%
  mutate(falta_mas1 = as.integer(servicios >= 2))

# objeto de Diseño ponderado
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# Seleccionando Variables binarias a comparar
vars <- c("household_has_disability",
          "head_female",
          "single_parent_relaxed",
          "household_survivor_violence")

# Dejando la categoría de Sí
res_list <- lapply(vars, function(v){
  fml <- reformulate(v)  # ~ var
  out <- svyby(~falta_mas1, fml, des_tmp, svymean, na.rm = TRUE, keep.names = FALSE)
  names(out)[names(out) == "falta_mas1"] <- "prop"
  names(out)[names(out) == v] <- "level"
  out$var <- v
  out
})

res <- bind_rows(res_list) %>%
  filter(level == 1) %>%
  mutate(
    var_label = case_when(
      var == "household_has_disability"    ~ "Con discapacidad en el hogar",
      var == "head_female"                 ~ "Jefatura femenina",
      var == "single_parent_relaxed"       ~ "Hogar monoparental",
      var == "household_survivor_violence" ~ "Antecedente de violencia",
      TRUE ~ var
    )
  ) %>%
  select(var_label, prop)

# Proporción cuando NO hay ninguna condición de vulnerabilidad
prop_none <- as.numeric(
  svymean(~falta_mas1,
          subset(des_tmp,
                 household_has_disability == 0 &
                 head_female == 0 &
                 single_parent_relaxed == 0 &
                 household_survivor_violence == 0),
          na.rm = TRUE)
)

ref_row <- tibble(
  var_label = "Ninguna condición de vulnerabilidad",
  prop = prop_none
)

# Reajustando el df para el gráfico
res2 <- bind_rows(res, ref_row) %>%
  mutate(
    prop_lab = paste0(round(100 * prop, 1), "%")
  ) %>%
  arrange(desc(prop)) %>%
  mutate(var_label = factor(var_label, levels = rev(var_label)))  # orden descendente

# Haciendo el gráfico
g_all <- ggplot(res2, aes(y = var_label, x = prop)) +
  geom_col(fill = "#003366", alpha = 0.9, width = 0.7) +
  geom_text(aes(label = prop_lab), hjust = -0.15, size = 3.8, color = "black") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     limits = c(0, max(res2$prop) * 1.08)) +
  labs(
    title = "Hogares migrantes venezolanos con carencia en alguno de los servicios básicos en Cartagena",
    subtitle = "Comparación por condición específica de vulnerabilidad",
    y = NULL,
    caption = "Nota: Para la construcción del gráfico se usó el factor de expansión para hogares"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )
print(g_all)

```

Ahora que sabemos que la proporción de hogares con carencia de dos servicios o más sí difiere para las diferentes condiciones de vulnerabilidad, vamos a averiguar si está relación se mantiene cuando agregamos estás condiciones en un solo indicador de vulnerabildiad.

```{r}
# Preparando los datos
cartagena_tmp <- cartagena %>%
  mutate(
    falta_mas1 = as.integer(servicios >= 2),
    vuln = suppressWarnings(as.numeric(as.character(vulnerability_score)))
  )

# Diseño ponderado
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# Proporción ponderada por índice de vulnerabilidad
out <- svyby(~falta_mas1, ~vuln, des_tmp, svymean, na.rm = TRUE, keep.names = FALSE)

# Preparando los datos
df_vul <- out %>%
  rename(prop = falta_mas1, score = vuln) %>%
  filter(!is.na(score), score %in% 0:4) %>%
  arrange(score) %>%
  mutate(
    score_f = factor(score, levels = 0:4, labels = c("0","1","2","3","4")),
    prop_lab = paste0(round(100*prop, 1), "%")
  )

# Creando el gráfico
g_vul <- ggplot(df_vul, aes(x = score_f, y = prop)) +
  geom_col(fill = "#003366", alpha = 0.9, width = 0.6) + 
  geom_text(aes(label = prop_lab), vjust = -0.6, size = 3.8, color = "black") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     limits = c(0, max(df_vul$prop) * 1.15)) +
  labs(
    title = "Hogares migrantes venezolanos con ≥2 servicios faltantes según índice de vulnerabilidad en Cartagena",
    x = "Índice de vulnerabilidad (0–4)",
    y = "Proporción de hogares",
    caption = "Ponderado por f_exp_hog. Indicador: servicios faltantes ≥ 2."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )

print(g_vul)

```

Debido a que a primera vista la gráfica puede resultar poco clara(intentamos mostrarle esta gráfica a personas cercanas que no concían el problema para ver qué mensaje transmitía la gráfica), entonces probamos otra forma de visualizar la misma información.

```{r}
df <- res2 %>% 
  mutate(var_label = factor(var_label, levels = rev(var_label)))

ggplot(df, aes(x = prop, y = var_label)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = prop - 1.96*sqrt(prop*(1-prop)/1000), 
                     xmax = prop + 1.96*sqrt(prop*(1-prop)/1000)), height = 0) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "Proporción con ≥2 carencias por condición",
       x = "Proporción ponderada", y = NULL,
       caption = "Cleveland dot-plot: prioriza posición sobre área.") +
  theme_minimal()

```

Considerando que no estaba muy contento con la visualización hasta este punto porque no lograba transmitir todas las posibilidades de carencia de servicios a través de todos los níveles nueva vulnerabilidad, decidimos hacer un grafico de barras apiladas de la carencia de servicios por cada una de las categorías del índice de vulnerabilidad que resultó mucho mejor y nos permitía ver mucho mejor la relación y responder la pregunta.

```{r}


# Preparación de datos 
df_plot <- cartagena %>%
  mutate(
    servicios = as.integer(servicios),
    vuln = as.integer(as.character(vulnerability_score))
  )

# Creando el objeto de Diseño Muestral Ponderado
des <- svydesign(ids = ~1, weights = ~f_exp_hog, data = df_plot)

# Tabla de Proporciones Ponderadas 
tab_w <- as.data.frame(svytable(~ servicios + vuln, design = des)) %>%
  as_tibble() %>% 
  rename(nw = Freq) %>%
  group_by(vuln) %>%
  mutate(prop = nw / sum(nw)) %>%
  ungroup() %>%
  mutate(
    servicios = factor(servicios, levels = 4:0, labels = c("4", "3", "2", "1", "0")),
    vuln      = factor(vuln, levels = 0:4, labels = c("0", "1", "2", "3", "4")),
    prop_lab  = paste0(round(100 * prop, 1), "%")
  )

#Haciendo el gráfico
g_stack_final_simple <- ggplot(tab_w, aes(x = vuln, y = prop, fill = servicios)) +
  geom_hline(yintercept = 0, color = "gray70", linetype = "solid") +
  geom_col(width = 0.8) +
  geom_text(
    data = ~ filter(.x, prop >= 0.05),
    aes(
      label = prop_lab,
      color = ifelse(servicios == "4", "especial", "normal")  
    ),
    position = position_stack(vjust = 0.5),
    size = 3.5,
    fontface = "bold",
    show.legend = FALSE
  ) +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_brewer(
    palette = "Blues",
    direction = -1,
    name = "Número de Carencias:"
  ) +
  scale_color_manual(  
    values = c("normal" = "gray20", "especial" = "white")  
  ) +
  labs(
    title = "Distribución porcentual de hogares según la vulnerabilidad\ny el número de carencias en servicios básicos",
    x = "Índice de Vulnerabilidad del hogar",
    y = "Proporción de hogares",
    caption = "Nota: Proporciones ponderadas con el factor de expansión del hogar (f_exp_hog).\nEl índice de vulnerabilidad va de 0 (sin condiciones) a 3 (tres condiciones de vulnerabilidad)."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold", size = rel(1.2)),
    plot.caption = element_text(hjust = 0, color = "gray40"),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10))
  )

print(g_stack_final_simple)

# exportando el gráfico
ggsave(
  filename = "results/figures/grafico11_servicios_VulScore_stacked.png",
  plot = g_stack_final_simple,
  width = 10,
  height = 7,
  dpi = 300,
  bg = "white"
)
```

Ahora vamos a hacer la misma gráfica pero intentando presentar como se comporta la carencia de servicios para cada una de las condiciones consideradas como de vulnerabilidad:

```{r}
# --------------------------------
# AJUSTANDO LOS DATOS PARA HACER LA GRÁFICA QUE QUEREMOS

# Definimos las variables de vulnerabilidad que vamos a analizar.
vars_vulnerabilidad <- c(
  "head_female", 
  "single_parent_relaxed", 
  "household_has_disability", 
  "household_survivor_violence"
)

# Creamos el data.frame largo, ideal para ggplot2.
df_largo <- cartagena %>%
  # Nos aseguramos de que las variables de vulnerabilidad sean numéricas (0 o 1)
  mutate(across(all_of(vars_vulnerabilidad), as.integer)) %>%
  
  # Creamos la categoría "Sin Vulnerabilidad".
  # Será 1 si la suma de todas las vulnerabilidades es 0.
  mutate(
    sin_vulnerabilidad = if_else(rowSums(select(., all_of(vars_vulnerabilidad))) == 0, 1, 0)
  ) %>%
  
  # Pivotamos los datos de formato ancho a largo.
  # Cada hogar tendrá ahora múltiples filas, una por cada condición de vulnerabilidad.
  tidyr::pivot_longer(
    cols = c(all_of(vars_vulnerabilidad), "sin_vulnerabilidad"),
    names_to = "grupo_vulnerabilidad",
    values_to = "presente"
  ) %>%
  
  # Filtramos para quedarnos solo con las condiciones que el hogar SÍ presenta.
  # Esto evita duplicar hogares en el conteo.
  filter(presente == 1) %>%
  
  # Limpiamos y ordenamos las etiquetas para el gráfico.
  mutate(
    grupo_vulnerabilidad = fct_recode(
      grupo_vulnerabilidad,
      "Sin Vulnerabilidad" = "sin_vulnerabilidad",
      "Jefatura Femenina" = "head_female",
      "Monoparental" = "single_parent_relaxed",
      "Con Discapacidad" = "household_has_disability",
      "Víctima de Violencia" = "household_survivor_violence"
    ),
    # Reordenamos los niveles para que "Sin Vulnerabilidad" aparezca primero.
    grupo_vulnerabilidad = fct_relevel(
      grupo_vulnerabilidad, 
      "Sin Vulnerabilidad", "Jefatura Femenina", "Monoparental", "Con Discapacidad"
    )
  )

# --------------------------------
# PREPARANDO EL DF PARA EL GRÁFICO

# Creamos el objeto de diseño muestral con los datos ya transformados.
des_largo <- svydesign(ids = ~1, weights = ~f_exp_hog, data = df_largo)

# Calculamos la tabla de proporciones ponderadas.
datos_grafico <- as.data.frame(svytable(~ servicios + grupo_vulnerabilidad, design = des_largo)) %>%
  as_tibble() %>%
  rename(conteo_pond = Freq) %>%
  group_by(grupo_vulnerabilidad) %>%
  mutate(proporcion = conteo_pond / sum(conteo_pond)) %>%
  ungroup() %>%
  mutate(
    # Ordenamos 'servicios' para el apilamiento (4 carencias arriba)
    servicios = factor(servicios, levels = 4:0),
    # Creamos la etiqueta de texto
    etiqueta_prop = paste0(round(100 * proporcion, 1), "%")
  )


# --------------------------------
# HACIENDO EL GRÁFICO

g_stack_final <- ggplot(datos_grafico, aes(x = grupo_vulnerabilidad, y = proporcion, fill = servicios)) +
  geom_hline(yintercept = 0, color = "gray70", linetype = "solid") +
  geom_col(width = 0.7) + 
  geom_text(
    data = ~ filter(.x, proporcion >= 0.02),
    aes(
      label = etiqueta_prop,
      color = ifelse(servicios == "4", "especial", "normal") 
    ),
    position = position_stack(vjust = 0.5),
    size = 3.5,
    fontface = "bold",
    show.legend = FALSE
  ) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_brewer(
    palette = "Blues",
    direction = -1,
    name = "Número de Carencias:"
  ) +
  scale_color_manual(values = c("normal" = "gray20", "especial" = "white")) +
  labs(
    title = "Distribución de carencias en servicios por condición de vulnerabilidad del hogar",
    x = "Condición de vulnerabilidad",
    y = "Proporción de hogares",
    caption = "Nota: Proporciones ponderadas con el factor de expansión del hogar (f_exp_hog)."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold", size = rel(1.2)),
    plot.caption = element_text(hjust = 0, color = "gray40"),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(angle = 15, hjust = 1) 
  )

print(g_stack_final)

# --------------------------------
# EXPORTANDO EL GRÁFICO
ggsave(
  filename = "results/figures/grafico12_servicios_por_condicion_final.png",
  plot = g_stack_final,
  width = 11,
  height = 8,
  dpi = 300,
  bg = "white"
)
```

# PARTE 4:Evidencia empírica y estimación
1. Describa el diseño del contraste estadísJco
1. Seleccione la prueba de acuerdo con la situación (por ejemplo, prueba t de
diferencia de medias, prueba de proporciones, etc.)
2. Explique brevemente qué se está comparando y cuál sería la expectaJva teórica o
empírica según el hecho esJlizado que se desea comprobar.
3. Señale si el contraste es bilateral o unilateral y cuál sería la dirección esperada del
efecto. Esto en línea con lo encontrado en el EDA
2. Revise los supuestos y ejecute la prueba
1. Verifique las condiciones necesarias para aplicar la prueba elegida (normalidad,
independencia, homogeneidad de varianzas, tamaño de muestra). En caso de que
alguna condición no se cumpla, jusJfique la prueba alternaJva empleada o las
transformaciones realizadas sobre los datos.
2. Ejecute la prueba y reporte los resultados relevantes: estadísJco de prueba, el
intervalo de confianza esJmado.
3. Reporte el p-valor de la prueba de hipótesis y explique qué significa en términos del
riesgo de error Jpo I.