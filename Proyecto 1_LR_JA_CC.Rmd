---
  title: "Proyecto1 : Explorando datos sobre migrantes venezolanos en Colombia"
subtitle: "Facultad de Economía, Universidad de los Andes"
author: "Camila Caraballo, Laura Rivera y Javier Amaya Nieto"
date: "2025-10-31"
output: html_document
---

# Setup del ambiente

```{r, include=FALSE}
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")

# Cargando los paquetes usando pacman
pacman::p_load(
  
  # A) Manipulación, limpieza y visualización de datos
  tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
  forcats,      # Herramientas para trabajar con variables categóricas (factores).
  tibble,       # Implementación moderna de data.frames.
  janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
  lubridate,    # Manejo avanzado de fechas y horas.
  skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
  stringi,      # Manipulación robusta de texto (strings).
  scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
  openxlsx,     # Guardar excel
  writexl,      # Guardar excel
  kableExtra,

  # B) Modelado y análisis estadístico/econométrico
  fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
  plm,          # Modelos econométricos para datos de panel.
  AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
  lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
  sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
  survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).

  # C) Importación, exportación y generación de reportes
  haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
  readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
  stargazer,    # Creación de tablas de regresión con formato de publicación.
  knitr         # Generación de reportes dinámicos.
)



```

# PARTE 0: Situación

Su grupo de trabajo hace parte de un equipo técnico que apoya a una alcaldía en un programa de mejora de la calidad de vida de hogares venezolanos. La alcaldía quiere mejorar la focalización de su respuesta en vivienda y servicios básicos, pero no sabe qué factores son los más importantes para idenficar condiciones de vida deficientes.

 a) Ajustes iniciales

-   Designando rutas de trabajo y carga de datos: en este paso se puede revisar rapidamente la base de hogares y se carga la base de personas debido a que se usarán algunas variable de esta última para construir unas variables de la base de hogares que será el foco de nuestro trabajo.

```{r}
# Rutas y datos iniciales
xlsx_path <- "data/2025 JNA VP.xlsx"
hogares <- read_excel(xlsx_path, sheet = "Hogares") %>% clean_names()
personas <- read_excel(xlsx_path, sheet = "Personas") %>% clean_names()
```

-   Estandarizar nombres (mayúsculas/acentos) en intro4 e intro5: en este paso ajustamos los nombres de departamento y municipio para mejorar la presentación de los datos de aquí en adelante. Y también se hace un proceso de estandarización usando clean:names() de janitor.

```{r}
# Cambiar nombres y estandarizar
data_hogares <- hogares %>%
   rename(
    DPNOM = intro4,  # Departamento
    MPIO  = intro5   # Municipio
  ) %>%
  mutate(
    DPNOM = DPNOM %>%
      str_to_lower() %>%
      str_trim() %>%
      stri_trans_general("Latin-ASCII") %>%
      str_to_title(),
    
    MPIO = MPIO %>%
      str_to_lower() %>%
      str_trim() %>%
      stri_trans_general("Latin-ASCII") %>%
      str_to_title()
  ) %>% 
  clean_names()

```

b) Selección de la ciudad

Considerando los requisitos del taller y la pregunta de indagación consignada en la sección *Parte 1.a*, que propone comparar las carencias en el acceso a servicios públicos entre hogares migrantes según su nivel de vulnerabilidad, esta sección explica la lógica utilizada para seleccionar una ciudad específica.

En el marco de un programa de mejora de la calidad de vida de hogares venezolanos —en el que nuestro equipo debe apoyar a la alcaldía de una de estos municipios— se decidió identificar la ciudad con la menor tasa de intención de migración a seis meses. Se parte de la premisa de que una población con baja movilidad ofrece un entorno más estable y predecible, lo que representa una ventaja estratégica para diseñar e implementar políticas públicas de largo plazo que fortalezcan la respuesta local en vivienda y servicios básicos.

Asimismo, se detalla el proceso de depuración de datos que permitió construir la variable de intención de movimiento y migración (**int_mov2**). Para ello, se recodificó la variable categórica *demo22* (intención de migración de alguno de los miembros del hogar en los siguientes seis meses) en una nueva variable binaria, **int_mov2**. Se asignó el valor **1** a las respuestas que indicaban planes de migración —ya fuera dentro de Colombia (cambio de municipio o departamento) o fuera del país— y el valor **0** a aquellas sin intención de desplazamiento.

```{r}

# convirtiendo texto categórico a factor
data_hogares <- data_hogares %>% mutate(across(where(is.character), as.factor))

# Creando la variable de intención de movimiento de ciudad
data_hogares <- data_hogares %>%
  mutate(
      int_mov2 = case_when(
      # Condiciones por las que se responde Sí=1
      str_detect(demo22, regex("^No sabe", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, irnos a otro país (diferente a Venezuela)", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, irnos a Venezuela", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, nos vamos a cambiar a otro departamento al interior de Colombia", ignore_case = TRUE)) ~ 1L,
      str_detect(demo22, regex("^Sí, nos vamos a cambiar de municipio pero en el mismo departamento actual", ignore_case = TRUE)) ~ 1L,

      # Condición de lo contrario 
      TRUE ~ 0L
    )
  )
```

Intención de migración

Esta sección presenta, como eje central, los municipios con menor intención de movilidad, complementados con aquellos de mayor intención y las principales razones de desplazamiento, buscando asegurar la coherencia de los hallazgos.

```{r}
# Preparación de datos
top10_muni_menor <- data_hogares %>%
  group_by(mpio) %>%
  summarise(
    n_encuestas = n(),  
    tasa_intencion = mean(int_mov2, na.rm = TRUE)
  ) %>%
  arrange(tasa_intencion) %>%
  slice_head(n = 10) %>%
  mutate(mpio = forcats::fct_rev(forcats::fct_reorder(mpio, tasa_intencion)))

# Gráfico1
# Definiendo colores para mostrar enfasis
color_resalte <- "#e41a1c" 
color_general <- "#003366" 

# Grafico
grafico1 <- ggplot(top10_muni_menor, aes(x = mpio, y = tasa_intencion)) +
  geom_col(aes(fill = ifelse(mpio == first(mpio), color_resalte, color_general)), alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(tasa_intencion, accuracy = 0.1)),
    hjust = -0.1,
    size = 3.5,
    color = "black"
  ) +
  coord_flip(clip = "off") +
  labs(
    title = "Top 10 municipios con menor intención de movilidad",
    subtitle = "Cartagena de Indias destaca por la menor proporción de hogares",
    x = "Municipio",
    y = "Proporción de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm"),
    legend.position = "none"
  ) +
  scale_y_continuous(labels = scales::percent) +
  scale_fill_identity()

print(grafico1)

# Guardando el gráfico
ggsave("results/grafico1.png", 
       plot = grafico1, width = 12, height = 6, dpi = 300)
```

De esta manera, se puede observar que la ciudad con una menor proporción de hogares con intención de movilidad o migración fuera de la ciudad donde residen actualmente es **Cartagena de Indias,** y que será el foco geográfico seleccionado para este análisis.Ahora presentaremos análisis complementarios de esta variable, emepezando por las ciudades con mayor intención de movilida.

```{r}

# Preparando los datos
tasas_muni <- data_hogares %>%
  group_by(mpio) %>%
 summarise(
   n = n(),
   tasa_intencion = mean(int_mov2, na.rm = TRUE)
 ) %>%
 arrange(tasa_intencion)

# TOP 10 de mayor a menor intención.
top10_muni_mayor <- tasas_muni %>%
  arrange(desc(tasa_intencion)) %>%  
  slice_head(n = 10) %>%             
  mutate(mpio = forcats::fct_reorder(mpio, tasa_intencion))

# Grafico
color_barras <- "#003366"  

grafico2 <- ggplot(top10_muni_mayor, aes(x = mpio, y = tasa_intencion)) +
  geom_col(fill = color_barras, alpha = 0.9) +
  geom_text(
    aes(label = scales::percent(tasa_intencion, accuracy = 0.1)),
    hjust = -0.1,
    size = 3.5,
    color = "black"
  ) +
  coord_flip(clip = "off") +
  labs(
    title = "Top 10 municipios con mayor intención de movilidad",
    x = "Municipio",
    y = "Proporción de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  ) +
  scale_y_continuous(labels = scales::percent)

print(grafico2)

# Guardando el gráfico
ggsave("results/grafico2.png", 
       plot = grafico2, width = 12, height = 6, dpi = 300)

```

En esta parte del análisis descriptivo llaman la atención varios municipios que, por su localización, pueden considerarse de **frontera o cercanos a zonas de tránsito migratorio** —como *Pasto, Arauca, Riohacha y Maicao*— los cuales presentan proporciones destacadas de hogares con intención de mudarse. Asimismo, aparecen **ciudades intermedias y grandes urbes** como *Bogotá, Soacha, Barranquilla, Medellín y Pereira*, que podrían funcionar como **destinos de llegada temporal** para migrantes venezolanos, en los que se establecen inicialmente con el fin de trabajar y reunir recursos que les permitan posteriormente desplazarse hacia un segundo destino. Estos hallazgos muestran consistencia con los resultados

Este patrón es consistente con las dinámicas migratorias documentadas en Colombia: los municipios de frontera suelen concentrar población migrante en tránsito, mientras que las grandes ciudades funcionan como polos de atracción por sus oportunidades laborales y por la existencia de redes de apoyo. La presencia simultánea de ambos tipos de municipios en los resultados refuerza la validez de este análisis inicial y aporta coherencia a la elección de **Cartagena de Indias** como ciudad foco para responder la pregunta planteada. Ahora vamos a presentar las razón principal por la cual los hogares quieren mudarse fuera de la ciudad donde residen actualmente y que proporciona una visión más completa de esta característica de intención de movilidad de los migrantes.

```{r}
### Razones principales porque los hogares se quieren mudar

# Seleccionar las variables
razones <- data_hogares %>%
  dplyr::select(
    proteccion1006_v_ctima_de_violencia_amenazas,
    proteccion1006_temor_por_la_situaci_n_general,
    proteccion1006_falta_de_empleo_bajos_ingres,
    proteccion1006_falta_de_acceso_a_alimentos,
    proteccion1006_falta_de_acceso_a_servicios_m,
    proteccion1006_falta_de_acceso_a_educaci_n,
    proteccion1006_desastres_naturales,
    proteccion1006_reunificaci_n_familiar,
    proteccion1006_no_sabe
  )

# Calculando las proporciones
frecuencias <- razones %>%
  summarise(across(everything(), ~ mean(.x, na.rm = TRUE))) %>%
  pivot_longer(cols = everything(),
               names_to = "razon",
               values_to = "proporcion")

# Diccionario 
dicc <- tibble(
  razon = c(
    "proteccion1006_v_ctima_de_violencia_amenazas",
    "proteccion1006_temor_por_la_situaci_n_general",
    "proteccion1006_falta_de_empleo_bajos_ingres",
    "proteccion1006_falta_de_acceso_a_alimentos",
    "proteccion1006_falta_de_acceso_a_servicios_m",
    "proteccion1006_falta_de_acceso_a_educaci_n",
    "proteccion1006_desastres_naturales",
    "proteccion1006_reunificaci_n_familiar",
    "proteccion1006_no_sabe"
  ),
  razon_label = c(
    "Víctima de violencia/amenazas",
    "Temor por la situación general",
    "Falta de empleo o bajos ingresos",
    "Falta de acceso a alimentos",
    "Falta de acceso a servicios médicos",
    "Falta de acceso a educación",
    "Desastres naturales",
    "Reunificación familiar",
    "No sabe"
  )
)

# Uniendo con el diccionario
frecuencias <- frecuencias %>%
  left_join(dicc, by = "razon") %>%
  mutate(porcentaje = proporcion * 100) %>%
  arrange(desc(porcentaje))

# Definir color
color_barras <- "#003366"

# Gráfico
grafico3 <- ggplot(frecuencias, aes(x = reorder(razon_label, porcentaje), y = porcentaje)) +
  geom_col(fill = color_barras) +
  geom_text(
    aes(label = paste0(round(porcentaje, 1), "%")),
    hjust = -0.1,
    size = 3.5
  ) +
  coord_flip() +
  labs(
    title = "Razones de intención de migrar",
    x = "Razón",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    plot.title = element_text(face = "bold", size = 14)
  ) +
  ylim(0, max(frecuencias$porcentaje) + 5)

print(grafico3)

# Guardar en carpeta results
ggsave("results/grafico3.png",
       plot = grafico3, width = 12, height = 6, dpi = 300)


```

# PARTE 1: Planteamiento de la pregunta de indagación

### a) Pregunta de indagación

Teniendo en cuenta los resultados presentados en la **PARTE 0\* Este trabajo busca responder la siguiente pregunta de investigación:\
**¿Existen diferencias en las carencias de acceso a servicios públicos entre hogares migrantes con distintos niveles de vulnerabilidad en Cartagena de Indias?\*\*

```{r}
# Filtrar Cartagena y migrantes
cartagena_pre <- data_hogares %>%
  filter(mpio == "Cartagena De Indias") 
```

Considerando la pregunta de investigación planteada, en esta sección se presentan los **análisis univariados** que permiten explorar con mayor detalle las variables centrales del estudio:

-   **Variable dependiente (Y):** *Carencia de acceso a servicios públicos*, que sintetiza las condiciones de vivienda en términos de energía electríca, gas, agua, acueducto y alcantarillado, y disposición de residuos.\
-   **Variable independiente (X):** *Score de vulnerabilidad*, construido a partir de cuatro condiciones clave de vulnerabilidad que se describirán por separado para facilitar su comprensión (jefatura femenida, hogar monoparental, antecedentes de violencia)

El objetivo de este apartado es caracterizar de manera individual estas variables, identificando su distribución y principales patrones, como paso previo al análisis bivariado que permitirá evaluar la relación entre ellas.

### b) Creación de variable dependiente

Se construye la variable *servicios* que mide la cantidad de servicios básicos de los que carece la vivienda y se construye a partir de las variables (electricidad, gas, alcantallirado, acueducto y recolección de basuras). Por cada servicio que hace falta en el hogar se cuenta como 1 y si carece de todos entonces cuenta como 5

```{r}
cartagena_pre <- cartagena_pre %>%
  mutate(servicios = 
           alojamiento4_alojamiento4_energia +
           alojamiento4_alojamiento4_gas +
           alojamiento4_alojamiento4_alcantarillado +
           alojamiento4_alojamiento4_acueducto +
           alojamiento4_alojamiento4_recoleccion)
```

### c) Creación de variables independientes

Para intentar análizar de forma diferencial las diferencias en las carencias de acceso a servicios públicos (variable dependiente), se construyó un **índice de vulnerabilidad** a nivel de hogar que sintetiza cuatro condiciones estructurales asociadas a un mayor riesgo social. Estas condiciones, consideradas de manera individual y en conjunto, permiten caracterizar la situación de vulnerabilidad de los hogares migrantes en Cartagena de Indias. Las variables consideradas son:

1.  **Jefatura femenina del hogar**: identifica si la persona cabeza de hogar es mujer.\
2.  **Hogar monoparental**: determina si el hogar está conformado por un padre o madre sin cónyuge y con hijos, o si incluye un “Papá/Mamá” con estado civil soltero, separado, divorciado o viudo.\
3.  **Presencia de personas con discapacidad**: señala si al menos un miembro del hogar reporta alguna limitación o barrera física.\
4.  **Antecedentes de violencia o amenazas**: registra si algún miembro del hogar ha sido víctima de violencia o amenazas.

A partir de estas cuatro dimensiones se calculó la variable de interés principal, el **índice de vulnerabilidad**, definido como un **puntaje aditivo de 0 a 4** que suma un punto por cada condición cumplida. Este índice ofrece una medida sintética de la vulnerabilidad de los hogares y servirá como **variable independiente (X)** en los análisis posteriores.

En los siguientes apartados se describe, paso a paso, el procedimiento para identificar cada una de las cuatro condiciones de vulnerabilidad, con sus respectivos resúmenes para Cartagena, el resto del país y el total nacional, antes de integrar la información en el índice final.

1) Jefatura femenina del hogar

```{r}
# 1. Preparar variable de sexo del jefe
hogares_out <- data_hogares %>%
  mutate(
    head_sex = if_else(demo3 == "Sí", demo2, demo4),
    head_female = if_else(head_sex == "Mujer", 1L, 0L)
  )

# 2. Resumen por región
resumen_jefatura <- bind_rows(
  # Cartagena vs Resto país
  hogares_out %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      con_jefatura_femenina = sum(head_female == 1, na.rm = TRUE),
      pct_jefatura_femenina = round(mean(coalesce(as.integer(head_female), 0L) == 1) * 100, 2),
      .groups = "drop"
    ),
  # Total país
  hogares_out %>%
    summarise(
      region = "Total país",
      hogares = n(),
      con_jefatura_femenina = sum(head_female == 1, na.rm = TRUE),
      pct_jefatura_femenina = round(mean(coalesce(as.integer(head_female), 0L) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))


# 3. Crear tabla HTML con formato “aer”
tabla1 <- resumen_jefatura %>%
  kable(
    format = "html",
    caption = "Jefatura femenina por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Con jefatura femenina", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  # Encabezado personalizado

# 4. Guardar tabla como HTML
save_kable(tabla1, "results/tabla1.html")


```

2) Hogar monoparental

```{r}
# 1. Estados civiles 
single_status <- c("Soltero/a", "Separado/a", "Divorciado/a", "Viudo/a")

# 2. Agregado por hogar desde la base de Personas
per_hh <- personas %>%
  group_by(id_hogar) %>%
  summarise(
    has_conyuge = any(miembros4 == "Conyugue", na.rm = TRUE),
    has_hijo    = any(miembros4 == "Hijo/a", na.rm = TRUE),
    papa_mama_single = any(miembros4 == "Papá/Mamá" & miembros20f %in% single_status, na.rm = TRUE),
    .groups = "drop"
  )

# 3. Información de hogares 
hog_min <- data_hogares %>%
  select(id_hogar, demo3, mpio) %>%
  mutate(respondent_is_head = demo3 == "Sí")

# 4. Identificar hogares monoparentales
hog_single <- hog_min %>%
  left_join(per_hh, by = "id_hogar") %>%
  mutate(
    via_A = respondent_is_head & has_hijo & !has_conyuge,
    via_B = !respondent_is_head & papa_mama_single,
    single_parent_relaxed = as.integer(via_A | via_B)
  )

# 5. Resumen por región
resumen_single <- bind_rows(
  hog_single %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_single_parent = sum(single_parent_relaxed == 1, na.rm = TRUE),
      pct_single_parent = round(mean(coalesce(as.integer(single_parent_relaxed), 0L) == 1) * 100, 2),
      .groups = "drop"
    ),
  hog_single %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_single_parent = sum(single_parent_relaxed == 1, na.rm = TRUE),
      pct_single_parent = round(mean(coalesce(as.integer(single_parent_relaxed), 0L) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 6. Crear tabla HTML con formato “aer”
tabla2 <- resumen_single %>%
  kable(
    format = "html",
    caption = "Hogares monoparentales por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares monoparentales", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  

# 7. Guardar tabla
save_kable(tabla2, "results/tabla2.html")

```

3) Personas con discapacidad

```{r}
# 1) Identificando personas con discapacidad
personas_disc <- personas %>%
  mutate(
    has_disability_person = as.integer(
      (salud12_barreras_salud_fisica == TRUE) |
        (miembros27_barre_discp == 1)
    )
  ) %>%
  select(id_hogar, id_persona, salud12_barreras_salud_fisica,
         miembros27_barre_discp, has_disability_person)

# 2) Agregado a nivel hogar
hog_disc <- personas_disc %>%
  group_by(id_hogar) %>%
  summarise(
    household_has_disability = as.integer(any(has_disability_person == 1, na.rm = TRUE)),
    .groups = "drop"
  )

# 3) Unir con hogares y agregar región
hogares_disability <- data_hogares %>%
  left_join(hog_disc, by = "id_hogar")

# 4) Resumen por región
resumen_disability <- bind_rows(
  hogares_disability %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_hh_con_discapacidad = sum(household_has_disability == 1, na.rm = TRUE),
      pct_hh_con_discapacidad = round(mean(replace(household_has_disability, is.na(household_has_disability), 0) == 1) * 100, 2),
      .groups = "drop"
    ),
  hogares_disability %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_hh_con_discapacidad = sum(household_has_disability == 1, na.rm = TRUE),
      pct_hh_con_discapacidad = round(mean(replace(household_has_disability, is.na(household_has_disability), 0) == 1) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 5) Crear tabla HTML con formato “aer”
tabla3 <- resumen_disability %>%
  kable(
    format = "html",
    caption = "Hogares con alguna persona con discapacidad por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares con discapacidad", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50") 

# 6) Guardar tabla como HTML
save_kable(tabla3, "results/tabla3.html")

```

4) Antecedentes de violencia o amenazas
```{r}
# 1) Identificando hogares con violencia para alguno de sus miembros
hogares_violencia_amenazas <- data_hogares %>%
  mutate(
    household_survivor_violence = if_else(
      proteccion1006_v_ctima_de_violencia_amenazas == 1, 1L, 0L, missing = 0L
    )
  )

# 2) Resumen por región
resumen_violencia_amenazas <- bind_rows(
  hogares_violencia_amenazas %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    group_by(region) %>%
    summarise(
      hogares = n(),
      n_hh_con_violencia = sum(household_survivor_violence == 1, na.rm = TRUE),
      pct_hh_con_violencia = round(mean(household_survivor_violence == 1, na.rm = TRUE) * 100, 2),
      .groups = "drop"
    ),
  hogares_violencia_amenazas %>%
    summarise(
      region = "Total país",
      hogares = n(),
      n_hh_con_violencia = sum(household_survivor_violence == 1, na.rm = TRUE),
      pct_hh_con_violencia = round(mean(household_survivor_violence == 1, na.rm = TRUE) * 100, 2)
    )
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# 3) Crear tabla HTML con formato “aer”
tabla4 <- resumen_violencia_amenazas %>%
  kable(
    format = "html",
    caption = "Hogares con algún miembro víctima de violencia o amenazas por región",
    digits = 2,
    col.names = c("Región", "Hogares", "Hogares con violencia", "% Hogares con violencia")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")  

# 4) Guardar tabla como HTML
save_kable(tabla4, "results/tabla4.html")
```


5) Índice de vulnerabilidad

Finalmente, el índice de vulnerabilidad es un puntaje aditivo (0–4) que suma cuatro puntos: (1) jefatura del hogar femenina; (2) hogar mono-parental, definido como jefe/a sin cónyuge y con hijos, o presencia de “Papá/Mamá” con estado civil soltero/separado/divorciado/viudo; (3) al menos una persona con discapacidad en el hogar; y (4) antecedente de violencia contra miembros del hogar (proteccion1006_v_ctima_de_violencia_amenazas). El código incluye una comparación de Cartagéna y el país.

```{r}
# 1) Construcción del score de vulnerabilidad
hogares_vulnerabilidad <- hogares_out %>%
  select(id_hogar, mpio, head_female, f_exp_hog) %>%
  left_join(hog_single %>% select(id_hogar, single_parent_relaxed), by = "id_hogar") %>%
  left_join(hogares_disability %>% select(id_hogar, household_has_disability), by = "id_hogar") %>%
  left_join(hogares_violencia_amenazas %>% select(id_hogar, household_survivor_violence), by = "id_hogar") %>%
  mutate(
    head_female                  = coalesce(as.integer(head_female), 0L),
    single_parent_relaxed        = coalesce(as.integer(single_parent_relaxed), 0L),
    household_has_disability     = coalesce(as.integer(household_has_disability), 0L),
    household_survivor_violence = coalesce(as.integer(household_survivor_violence), 0L),
    vulnerability_score = head_female +
                          single_parent_relaxed +
                          household_has_disability +
                          household_survivor_violence
  )

# 2a) Tabla “larga”: conteos y porcentajes por score y región
resumen_score <- bind_rows(
  hogares_vulnerabilidad %>%
    mutate(region = if_else(mpio == "Cartagena De Indias", "Cartagena", "Resto país")) %>%
    count(region, vulnerability_score, name = "n") %>%
    group_by(region) %>% mutate(pct = round(100 * n / sum(n), 2)) %>% ungroup(),
  hogares_vulnerabilidad %>%
    count(vulnerability_score, name = "n") %>%
    mutate(region = "Total país") %>%
    group_by(region) %>% mutate(pct = round(100 * n / sum(n), 2)) %>% ungroup()
) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")),
          vulnerability_score)

# Tabla larga HTML
tabla5 <- resumen_score %>%
  kable(
    format = "html",
    caption = "Distribución del índice de vulnerabilidad por score y región (tabla larga)",
    digits = 2,
    col.names = c("Región", "Score de vulnerabilidad", "N", "%")
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

# Guardar tabla larga
save_kable(tabla5, "results/tabla5.html")

# 2b) Tabla “ancha”: porcentajes por columnas 0–4
tabla_score_pct <- resumen_score %>%
  select(region, vulnerability_score, pct) %>%
  pivot_wider(names_from = vulnerability_score, values_from = pct, values_fill = 0) %>%
  arrange(factor(region, levels = c("Cartagena", "Resto país", "Total país")))

# Tabla ancha HTML
tabla6 <- tabla_score_pct %>%
  kable(
    format = "html",
    caption = "Distribución del índice de vulnerabilidad por región (tabla ancha, %)",
    digits = 2
  ) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed", "responsive"),
    full_width = FALSE,
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#2C3E50")

# Guardar tabla ancha
save_kable(tabla6, "results/tabla6.html")

```


### d) Integración de variables en una base

Ahora vamos a integrar las variables necesarias para los análisis de las siguientes secciones:

```{r}

# copiando el DF de variables definitivas por hogar pero solo para Cartagena - VARIABLE DEPENDIENTE
cartagena_dep <- cartagena_pre %>% 
                  dplyr::select(id_hogar,
                                servicios, 
                                alojamiento4_alojamiento4_energia, 
                                alojamiento4_alojamiento4_gas,
                                alojamiento4_alojamiento4_alcantarillado,
                                alojamiento4_alojamiento4_acueducto,
                                alojamiento4_alojamiento4_recoleccion)


# copiando el DF de variables definitivas por hogar pero solo para Cartagena - VARIABLE INDEPENDIENTE
cartagena_ind <- hogares_vulnerabilidad %>%
                  filter(mpio=="Cartagena De Indias") %>% 
                  dplyr::select(id_hogar, 
                                head_female, 
                                single_parent_relaxed, 
                                household_has_disability,
                                household_survivor_violence, 
                                vulnerability_score,
                                f_exp_hog)


# OTRAS VARIABLES
# se deja abierta por si es requerido


# Uniendo las bases de datos
cartagena <- left_join(cartagena_dep, cartagena_ind, by = "id_hogar")

```

# PARTE 2: Análisis univariado

Antes de cruzar variables, se debe entender cada variable por sí sola: su codificación, distribución, faltantes y posibles errores. Esto asegura que las comparaciones bivariadas no estén sesgadas pordatos mal definidos. ¿Qué abordar para cada variable? Tipo y codificación: ¿numérica, categórica (nominal/ordinal),fecha, texto? ¿Binarias están en 0/1?

### a) Variable dependiente: Servicios

```{r}

# 1. Tabla resumen
resumen_servicios <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena$servicios)),
    sum(is.na(cartagena$servicios)),
    length(unique(cartagena$servicios)),
    min(cartagena$servicios, na.rm = TRUE),
    quantile(cartagena$servicios, 0.25, na.rm = TRUE),
    median(cartagena$servicios, na.rm = TRUE),
    mean(cartagena$servicios, na.rm = TRUE),
    quantile(cartagena$servicios, 0.75, na.rm = TRUE),
    max(cartagena$servicios, na.rm = TRUE)
  )
)

# 1.2 Generar tabla 
tabla_resumen <- resumen_servicios %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable dependiente: Servicios</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # <-- Encabezado azul oscuro

# 1.3 Guardar tabla 
save_kable(tabla_resumen, "results/resumen_servicios.html")


# 2. Tabla de distribución
tabla_resumen <- cartagena %>%
  count(servicios) %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    servicios_label = case_when(
      servicios == 0 ~ "Sin carencias",
      servicios == 1 ~ "1 carencia",
      servicios == 2 ~ "2 carencias",
      servicios == 3 ~ "3 carencias",
      servicios == 4 ~ "4 carencias",
      TRUE ~ "No sabe/NA"
    )
  )

# 2.1 Gráfico
grafico_servicios <- ggplot(tabla_resumen, aes(x = servicios_label, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Carencia de acceso a servicios públicos",
    subtitle = "Distribución de hogares según número de carencias",
    x = "Número de carencias reportadas",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_servicios)

ggsave("results/grafico_servicios.png",
       plot = grafico_servicios, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo <- "
Notas de método:
- Se estandarizaron las etiquetas y las categorías con valores entre 0 y 5.
- No se encontraron valores fuera del rango 0–5.
- Las barras de error no se aplican porque la variable es discreta.
- Los valores NA se reportan explícitamente y no fueron imputados.
- Las categorías con frecuencia menor al 3% se mantuvieron dado su significado sustantivo.
"

writeLines(notas_metodo, "results/notas_metodo_servicios.txt")

```

Se aplicó el factor de expansión de hogares (F_EXP_hog) para calcular la distribución, con el fin de garantizar que los resultados reflejen la distribución poblacional y no solo la muestra encuestada. Esto significa que cada observación representa un número mayor de hogares en la población, y los totales se obtienen sumando los pesos en lugar de contar registros.
```{r}

# 1. Estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$servicios)))

tabla7 <- estructura %>%
  kable("html", caption = "Estructura de la variable: Carencia de servicios públicos") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"))
save_kable(tabla7, "results/tabla7.html")


# 1.2 Tablas sin y con ponderación
# Sin ponderar
tabla_simple_serv <- cartagena %>%
  count(servicios) %>%
  mutate(
    n_sinpond = as.numeric(n),
    porc_sinpond = round(100 * n / sum(n), 1)
  ) %>%
  select(servicios, n_sinpond, porc_sinpond)

# 1.3 Ponderada (con factor de expansión)
tabla_pond_serv <- cartagena %>%
  group_by(servicios) %>%
  summarise(n_pond = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))

# 1.4 Unir tablas lado a lado 
tabla_comp_serv <- tabla_simple_serv %>%
  full_join(tabla_pond_serv, by = "servicios") %>%
  arrange(servicios)

# 1.5 Crear tabla HTML 
tabla8 <- tabla_comp_serv %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable dependiente: Servicios</b>",
    col.names = c("Servicios", "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
    digits = 1
  ) %>%
  add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366") # encabezado azul oscuro

save_kable(tabla8, "results/tabla8.html")


# 2. Tabla para gráfico
tabla_grafico <- tabla_comp_serv %>%
  select(servicios, porc_sinpond, porc_pond) %>%
  pivot_longer(cols = c(porc_sinpond, porc_pond),
               names_to = "tipo", values_to = "porc") %>%
  mutate(
    tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar")
  )

# 2.1 Gráfico comparativo
grafico6 <- ggplot(tabla_grafico, aes(x = factor(servicios), y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.4,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Carencias en servicios básicos en los hogares",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Número de servicios faltantes",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Guardar gráfico
ggsave("results/grafico6.png",
       plot = grafico6, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo <- "
Notas de método:
- La variable 'servicios' mide el número de carencias en el acceso a servicios básicos (0 a 5).
- La tabla presenta los conteos (N) y proporciones (%) comparando resultados sin ponderar y ponderados por el factor de expansión del hogar (f_exp_hog).
- Los valores ponderados reflejan la distribución poblacional representativa.
- No se identificaron valores fuera del rango 0–5.
- Los valores NA se reportan explícitamente y no se imputaron.
- Las categorías con frecuencia menor al 3% se mantuvieron dada su relevancia sustantiva.
"

writeLines(notas_metodo, "results/notas_metodo_servicios.txt")


# 4. Calcular barras de error (IC 95%)
tabla_grafico_ic <- tabla_comp_serv %>%
  mutate(
    p = porc_pond / 100,
    n = n_pond,
    se = sqrt(p * (1 - p) / n),
    ic_inf = 100 * (p - 1.96 * se),
    ic_sup = 100 * (p + 1.96 * se)
  )

# 4.1 Gráfico con barras de error
grafico6_ic <- ggplot(tabla_grafico_ic, aes(x = factor(servicios), y = porc_pond)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_errorbar(aes(ymin = ic_inf, ymax = ic_sup), width = 0.2, color = "black") +
  geom_text(aes(label = paste0(round(porc_pond, 1), "%")),
            vjust = -0.4, size = 3.5, color = "black") +
  labs(
    title = "Carencias en servicios básicos en los hogares",
    subtitle = "Porcentaje ponderado con intervalos de confianza al 95%",
    x = "Número de servicios faltantes",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0)
  )

print(grafico6_ic)


```





### b) Variables independientes

####1) Jefatura femenina del hogar

La variable head_female es una variable binaria, donde 1 corresponde a jefatura femenina y 0 a jefatura masculina, sin valores faltantes ni atípicos.

```{r}

# 1. Tabla resumen
resumen_headfem <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena$head_female)),
    sum(is.na(cartagena$head_female)),
    length(unique(cartagena$head_female)),
    min(cartagena$head_female, na.rm = TRUE),
    quantile(cartagena$head_female, 0.25, na.rm = TRUE),
    median(cartagena$head_female, na.rm = TRUE),
    mean(cartagena$head_female, na.rm = TRUE),
    quantile(cartagena$head_female, 0.75, na.rm = TRUE),
    max(cartagena$head_female, na.rm = TRUE)
  )
)

# 1.2 Generar tabla 
tabla_resumen_headfem <- resumen_headfem %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Jefatura femenina del hogar</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # Encabezado azul oscuro

# 1.3 Guardar tabla 
save_kable(tabla_resumen_headfem, "results/resumen_headfem.html")


# 2. Tabla de distribución
tabla_resumen_headfem <- cartagena %>%
  count(head_female) %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    head_female_label = case_when(
      head_female == 0 ~ "Jefe hombre",
      head_female == 1 ~ "Jefa mujer",
      TRUE ~ "No sabe/NA"
    )
  )

# 2.1 Gráfico
grafico_headfem <- ggplot(tabla_resumen_headfem, aes(x = head_female_label, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Jefatura femenina del hogar",
    subtitle = "Distribución de hogares según condición de jefatura",
    x = "Condición de jefatura del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_headfem)

ggsave("results/grafico_headfem.png",
       plot = grafico_headfem, width = 10, height = 6, dpi = 300)


# 3. Notas de método
notas_metodo_headfem <- "
Notas de método:
- La variable 'head_female' identifica si el hogar tiene jefatura femenina (1 = mujer, 0 = hombre).
- Se estandarizaron las etiquetas de acuerdo con la codificación binaria.
- No se identificaron valores fuera del rango esperado (0–1).
- Las barras de error no se aplican porque la variable es discreta y categórica.
- Los valores NA se reportan explícitamente y no fueron imputados.
"

writeLines(notas_metodo_headfem, "results/notas_metodo_headfem.txt")

```

Con factor expansión:

```{r}
# 1. Estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$head_female)))

tabla7_fem <- estructura %>%
  kable("html", caption = "Estructura de la variable: Jefatura femenina del hogar") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"))

save_kable(tabla7_fem, "results/tabla7_headfem.html")

# 1.2 Tablas sin y con ponderación
# Sin ponderar
tabla_simple_fem <- cartagena %>%
  count(head_female) %>%
  mutate(
    n_sinpond = as.numeric(n),
    porc_sinpond = round(100 * n / sum(n), 1)
  ) %>%
  select(head_female, n_sinpond, porc_sinpond)

# 1.3 Ponderada (con factor de expansión)
tabla_pond_fem <- cartagena %>%
  group_by(head_female) %>%
  summarise(n_pond = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))

# 1.4 Unir tablas lado a lado 
tabla_comp_fem <- tabla_simple_fem %>%
  full_join(tabla_pond_fem, by = "head_female") %>%
  arrange(head_female)

# 1.5 Crear tabla HTML 
tabla8_fem <- tabla_comp_fem %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable dependiente: Jefatura femenina del hogar</b>",
    col.names = c("Jefatura femenina", "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
    digits = 1
  ) %>%
  add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")

save_kable(tabla8_fem, "results/tabla8_headfem.html")

# 2. Tabla para gráfico
tabla_grafico_fem <- tabla_comp_fem %>%
  select(head_female, porc_sinpond, porc_pond) %>%
  pivot_longer(cols = c(porc_sinpond, porc_pond),
               names_to = "tipo", values_to = "porc") %>%
  mutate(
    tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"),
    head_female = factor(head_female,
                         levels = c(0,1),
                         labels = c("Jefe hombre", "Jefe mujer"))
  )

# 2.1 Gráfico comparativo
grafico_fem <- ggplot(tabla_grafico_fem, aes(x = head_female, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.4,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Jefatura femenina del hogar",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Condición de jefatura",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

ggsave("results/grafico_headfem.png", plot = grafico_fem, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo_fem <- "
Notas de método:
- La variable 'head_female' identifica si el hogar tiene jefatura femenina (1 = mujer, 0 = hombre).
- La tabla compara los conteos (N) y proporciones (%) sin ponderar y ponderados por el factor de expansión (f_exp_hog).
- Los valores ponderados representan la distribución poblacional ajustada.
- No se identificaron valores perdidos o inconsistentes.
"

writeLines(notas_metodo_fem, "results/notas_metodo_headfem.txt")

# 4. Calcular barras de error (IC 95%)
tabla_grafico_ic_fem <- tabla_comp_fem %>%
  mutate(
    p = porc_pond / 100,
    n = n_pond,
    se = sqrt(p * (1 - p) / n),
    ic_inf = 100 * (p - 1.96 * se),
    ic_sup = 100 * (p + 1.96 * se)
  )

# 4.1 Gráfico con barras de error
grafico_fem_ic <- ggplot(tabla_grafico_ic_fem, aes(x = factor(head_female,
                                                             labels = c("Jefe hombre", "Jefe mujer")),
                                                  y = porc_pond)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_errorbar(aes(ymin = ic_inf, ymax = ic_sup), width = 0.2, color = "black") +
  geom_text(aes(label = paste0(round(porc_pond, 1), "%")),
            vjust = -0.4, size = 3.5, color = "black") +
  labs(
    title = "Jefatura femenina del hogar",
    subtitle = "Porcentaje ponderado con intervalos de confianza al 95%",
    x = "Condición de jefatura",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0)
  )

print(grafico_fem_ic)

```

####2) Hogar monoparental:

De la variable single_parent_relaxed creada anteriormente, se puede decir que no se identificaron valores faltantes en la variable y los únicos valores posibles fueron 0 y 1. Ahora bien a continuación se evidencia que esta variable sin ponderar representa un 26,6 % de los hogares están conformados por un solo adulto responsable de hijos, mientras que el 73,4 % restante cuenta con dos o más adultos.

Al ponderar con el factor de expansión de los hogares, la proporción de hogares con un solo adulto responsable baja a 19 %, lo que refleja la representatividad de estos hogares en la población. Esta información es importante para identificar posibles necesidades de apoyo social o programas dirigidos a hogares con un solo adulto a cargo.

```{r}
# 1. Tabla resumen
resumen_singleparent <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena$single_parent_relaxed)),
    sum(is.na(cartagena$single_parent_relaxed)),
    length(unique(cartagena$single_parent_relaxed)),
    min(cartagena$single_parent_relaxed, na.rm = TRUE),
    quantile(cartagena$single_parent_relaxed, 0.25, na.rm = TRUE),
    median(cartagena$single_parent_relaxed, na.rm = TRUE),
    mean(cartagena$single_parent_relaxed, na.rm = TRUE),
    quantile(cartagena$single_parent_relaxed, 0.75, na.rm = TRUE),
    max(cartagena$single_parent_relaxed, na.rm = TRUE)
  )
)

# 1.2 Generar tabla 
tabla_resumen_singleparent <- resumen_singleparent %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar monoparental (definición relajada)</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # Encabezado azul oscuro

# 1.3 Guardar tabla 
save_kable(tabla_resumen_singleparent, "results/resumen_singleparent.html")


# 2. Tabla de distribución
tabla_resumen_singleparent <- cartagena %>%
  count(single_parent_relaxed) %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    single_parent_label = case_when(
      single_parent_relaxed == 0 ~ "No monoparental",
      single_parent_relaxed == 1 ~ "Hogar monoparental",
      TRUE ~ "No sabe/NA"
    )
  )

# 2.1 Gráfico
grafico_singleparent <- ggplot(tabla_resumen_singleparent, aes(x = single_parent_label, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Hogares monoparentales (definición relajada)",
    subtitle = "Distribución de hogares según presencia de jefatura monoparental",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_singleparent)

ggsave("results/grafico_singleparent.png",
       plot = grafico_singleparent, width = 10, height = 6, dpi = 300)


# 3. Notas de método
notas_metodo_singleparent <- "
Notas de método:
- La variable 'single_parent_relaxed' identifica si el hogar es monoparental bajo una definición relajada (1 = sí, 0 = no).
- Se validó que la codificación sea binaria (0 y 1).
- Los valores NA se reportan explícitamente y no fueron imputados.
- No se aplican barras de error al gráfico porque la variable es categórica y discreta.
- La definición relajada considera hogares donde el jefe o jefa convive con hijos sin pareja residente, sin distinguir por sexo del jefe.
"

writeLines(notas_metodo_singleparent, "results/notas_metodo_singleparent.txt")


```
Ahora con factor expansión

```{r}

# 1. Estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$single_parent_relaxed)))

tabla7_single <- estructura %>%
  kable("html", caption = "Estructura de la variable: Hogar monoparental (definición relajada)") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"))

save_kable(tabla7_single, "results/tabla7_single_parent_relaxed.html")

# 1.2 Tablas sin y con ponderación
# Sin ponderar
tabla_simple_single <- cartagena %>%
  count(single_parent_relaxed) %>%
  mutate(
    n_sinpond = as.numeric(n),
    porc_sinpond = round(100 * n / sum(n), 1)
  ) %>%
  select(single_parent_relaxed, n_sinpond, porc_sinpond)

# 1.3 Ponderada (con factor de expansión)
tabla_pond_single <- cartagena %>%
  group_by(single_parent_relaxed) %>%
  summarise(n_pond = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))

# 1.4 Unir tablas lado a lado 
tabla_comp_single <- tabla_simple_single %>%
  full_join(tabla_pond_single, by = "single_parent_relaxed") %>%
  arrange(single_parent_relaxed)

# 1.5 Crear tabla HTML 
tabla8_single <- tabla_comp_single %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar monoparental (definición relajada)</b>",
    col.names = c("Hogar monoparental", "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
    digits = 1
  ) %>%
  add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")

save_kable(tabla8_single, "results/tabla8_single_parent_relaxed.html")

# 2. Tabla para gráfico
tabla_grafico_single <- tabla_comp_single %>%
  select(single_parent_relaxed, porc_sinpond, porc_pond) %>%
  pivot_longer(cols = c(porc_sinpond, porc_pond),
               names_to = "tipo", values_to = "porc") %>%
  mutate(
    tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"),
    single_parent_relaxed = factor(single_parent_relaxed,
                                   levels = c(0, 1),
                                   labels = c("No monoparental", "Monoparental"))
  )

# 2.1 Gráfico comparativo
grafico_single <- ggplot(tabla_grafico_single, aes(x = single_parent_relaxed, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.4,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Hogar monoparental (definición relajada)",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Condición del hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

ggsave("results/grafico_single_parent_relaxed.png", plot = grafico_single, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo_single <- "
Notas de método:
- La variable 'single_parent_relaxed' identifica si el hogar es monoparental bajo una definición relajada (1 = sí, 0 = no).
- La tabla compara los conteos (N) y proporciones (%) sin ponderar y ponderados por el factor de expansión (f_exp_hog).
- Los valores ponderados reflejan la distribución ajustada a la población.
- No se identificaron valores perdidos o inconsistentes en la variable.
"

writeLines(notas_metodo_single, "results/notas_metodo_single_parent_relaxed.txt")

# 4. Calcular barras de error (IC 95%)
tabla_grafico_ic_single <- tabla_comp_single %>%
  mutate(
    p = porc_pond / 100,
    n = n_pond,
    se = sqrt(p * (1 - p) / n),
    ic_inf = 100 * (p - 1.96 * se),
    ic_sup = 100 * (p + 1.96 * se)
  )

# 4.1 Gráfico con barras de error
grafico_single_ic <- ggplot(tabla_grafico_ic_single, aes(
  x = factor(single_parent_relaxed, labels = c("No monoparental", "Monoparental")),
  y = porc_pond
)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_errorbar(aes(ymin = ic_inf, ymax = ic_sup), width = 0.2, color = "black") +
  geom_text(aes(label = paste0(round(porc_pond, 1), "%")),
            vjust = -0.4, size = 3.5, color = "black") +
  labs(
    title = "Hogar monoparental (definición relajada)",
    subtitle = "Porcentaje ponderado con intervalos de confianza al 95%",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0)
  )

print(grafico_single_ic)

```


####3) Personas con discapacidad

```{r}
# 1. Tabla resumen
resumen_disability <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena$household_has_disability)),
    sum(is.na(cartagena$household_has_disability)),
    length(unique(cartagena$household_has_disability)),
    min(cartagena$household_has_disability, na.rm = TRUE),
    quantile(cartagena$household_has_disability, 0.25, na.rm = TRUE),
    median(cartagena$household_has_disability, na.rm = TRUE),
    mean(cartagena$household_has_disability, na.rm = TRUE),
    quantile(cartagena$household_has_disability, 0.75, na.rm = TRUE),
    max(cartagena$household_has_disability, na.rm = TRUE)
  )
)

# 1.2 Generar tabla 
tabla_resumen_disability <- resumen_disability %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar con personas con discapacidad</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # Encabezado azul oscuro

# 1.3 Guardar tabla 
save_kable(tabla_resumen_disability, "results/resumen_disability.html")


# 2. Tabla de distribución
tabla_resumen_disability <- cartagena %>%
  count(household_has_disability) %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    disability_label = case_when(
      household_has_disability == 0 ~ "Sin personas con discapacidad",
      household_has_disability == 1 ~ "Con personas con discapacidad",
      TRUE ~ "No sabe/NA"
    )
  )

# 2.1 Gráfico
grafico_disability <- ggplot(tabla_resumen_disability, aes(x = disability_label, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Hogares con personas con discapacidad",
    subtitle = "Distribución de hogares según presencia de miembros con discapacidad",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_disability)

ggsave("results/grafico_disability.png",
       plot = grafico_disability, width = 10, height = 6, dpi = 300)


# 3. Notas de método
notas_metodo_disability <- "
Notas de método:
- La variable 'household_has_disability' identifica si el hogar cuenta con al menos una persona con discapacidad (1 = sí, 0 = no).
- Se confirmó que la variable tiene codificación binaria (0 y 1).
- Los valores NA se reportan explícitamente y no fueron imputados.
- No se aplican barras de error porque la variable es discreta y categórica.
- La mayoría de hogares no presentan personas con discapacidad, lo cual explica la asimetría en la distribución.
"

writeLines(notas_metodo_disability, "results/notas_metodo_disability.txt")

```

Con factor expansión
```{r}
# 1. Estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$household_has_disability)))

tabla7_disc <- estructura %>%
  kable("html", caption = "Estructura de la variable: Hogar con personas con discapacidad") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"))

save_kable(tabla7_disc, "results/tabla7_household_has_disability.html")

# 1.2 Tablas sin y con ponderación
# Sin ponderar
tabla_simple_disc <- cartagena %>%
  count(household_has_disability) %>%
  mutate(
    n_sinpond = as.numeric(n),
    porc_sinpond = round(100 * n / sum(n), 1)
  ) %>%
  select(household_has_disability, n_sinpond, porc_sinpond)

# 1.3 Ponderada (con factor de expansión)
tabla_pond_disc <- cartagena %>%
  group_by(household_has_disability) %>%
  summarise(n_pond = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))

# 1.4 Unir tablas lado a lado 
tabla_comp_disc <- tabla_simple_disc %>%
  full_join(tabla_pond_disc, by = "household_has_disability") %>%
  arrange(household_has_disability)

# 1.5 Crear tabla HTML 
tabla8_disc <- tabla_comp_disc %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar con personas con discapacidad</b>",
    col.names = c("Hogar con discapacidad", "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
    digits = 1
  ) %>%
  add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")

save_kable(tabla8_disc, "results/tabla8_household_has_disability.html")

# 2. Tabla para gráfico
tabla_grafico_disc <- tabla_comp_disc %>%
  select(household_has_disability, porc_sinpond, porc_pond) %>%
  pivot_longer(cols = c(porc_sinpond, porc_pond),
               names_to = "tipo", values_to = "porc") %>%
  mutate(
    tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"),
    household_has_disability = factor(household_has_disability,
                                      levels = c(0, 1),
                                      labels = c("Sin discapacidad", "Con discapacidad"))
  )

# 2.1 Gráfico comparativo
grafico_disc <- ggplot(tabla_grafico_disc, aes(x = household_has_disability, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.4,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Hogar con personas con discapacidad",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Condición del hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

ggsave("results/grafico_household_has_disability.png", plot = grafico_disc, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo_disc <- "
Notas de método:
- La variable 'household_has_disability' identifica si en el hogar hay al menos una persona con discapacidad (1 = sí, 0 = no).
- La tabla compara los conteos (N) y proporciones (%) sin ponderar y ponderados por el factor de expansión (f_exp_hog).
- Los valores ponderados reflejan la distribución ajustada a la población.
- La mayoría de hogares no reportan personas con discapacidad, por lo que la incidencia de esta condición es baja.
"

writeLines(notas_metodo_disc, "results/notas_metodo_household_has_disability.txt")

# 4. Calcular barras de error (IC 95%)
tabla_grafico_ic_disc <- tabla_comp_disc %>%
  mutate(
    p = porc_pond / 100,
    n = n_pond,
    se = sqrt(p * (1 - p) / n),
    ic_inf = 100 * (p - 1.96 * se),
    ic_sup = 100 * (p + 1.96 * se)
  )

# 4.1 Gráfico con barras de error
grafico_disc_ic <- ggplot(tabla_grafico_ic_disc, aes(
  x = factor(household_has_disability, labels = c("Sin discapacidad", "Con discapacidad")),
  y = porc_pond
)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_errorbar(aes(ymin = ic_inf, ymax = ic_sup), width = 0.2, color = "black") +
  geom_text(aes(label = paste0(round(porc_pond, 1), "%")),
            vjust = -0.4, size = 3.5, color = "black") +
  labs(
    title = "Hogar con personas con discapacidad",
    subtitle = "Porcentaje ponderado con intervalos de confianza al 95%",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0)
  )

print(grafico_disc_ic)

```


####4) Antecedentes de violencia o amenazas:

La variable *household_survivor_violence* indica si el hogar sufrió violencia. 
```{r}
# 1. Tabla resumen
resumen_violence <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena$household_survivor_violence)),
    sum(is.na(cartagena$household_survivor_violence)),
    length(unique(cartagena$household_survivor_violence)),
    min(cartagena$household_survivor_violence, na.rm = TRUE),
    quantile(cartagena$household_survivor_violence, 0.25, na.rm = TRUE),
    median(cartagena$household_survivor_violence, na.rm = TRUE),
    mean(cartagena$household_survivor_violence, na.rm = TRUE),
    quantile(cartagena$household_survivor_violence, 0.75, na.rm = TRUE),
    max(cartagena$household_survivor_violence, na.rm = TRUE)
  )
)

# 1.2 Generar tabla 
tabla_resumen_violence <- resumen_violence %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar con víctimas de violencia</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # Encabezado azul oscuro

# 1.3 Guardar tabla 
save_kable(tabla_resumen_violence, "results/resumen_violence.html")


# 2. Tabla de distribución
tabla_resumen_violence <- cartagena %>%
  count(household_survivor_violence) %>%
  mutate(
    porc = round(100 * n / sum(n), 1),
    violence_label = case_when(
      household_survivor_violence == 0 ~ "Sin víctimas de violencia",
      household_survivor_violence == 1 ~ "Con víctimas de violencia",
      TRUE ~ "No sabe/NA"
    )
  )

# 2.1 Gráfico
grafico_violence <- ggplot(tabla_resumen_violence, aes(x = violence_label, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Hogares con víctimas de violencia",
    subtitle = "Distribución de hogares según experiencia de violencia",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_violence)

ggsave("results/grafico_violence.png",
       plot = grafico_violence, width = 10, height = 6, dpi = 300)


# 3. Notas de método
notas_metodo_violence <- "
Notas de método:
- La variable 'household_survivor_violence' identifica si en el hogar hay al menos una persona sobreviviente de violencia (1 = sí, 0 = no).
- Se validó que la codificación sea binaria (0 y 1).
- Los valores NA se reportan explícitamente y no fueron imputados.
- No se aplican barras de error porque la variable es categórica y discreta.
- La baja proporción de hogares con víctimas refleja la sensibilidad del tema y posible subregistro en la respuesta.
"

writeLines(notas_metodo_violence, "results/notas_metodo_violence.txt")

```

Ahora con factor expansión
```{r}

# 1. Estructura de la variable
estructura <- data.frame(estructura = capture.output(str(cartagena$household_survivor_violence)))

tabla7_viol <- estructura %>%
  kable("html", caption = "Estructura de la variable: Hogar con sobrevivientes de violencia") %>%
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover", "condensed"))

save_kable(tabla7_viol, "results/tabla7_household_survivor_violence.html")

# 1.2 Tablas sin y con ponderación
# Sin ponderar
tabla_simple_viol <- cartagena %>%
  count(household_survivor_violence) %>%
  mutate(
    n_sinpond = as.numeric(n),
    porc_sinpond = round(100 * n / sum(n), 1)
  ) %>%
  select(household_survivor_violence, n_sinpond, porc_sinpond)

# 1.3 Ponderada (con factor de expansión)
tabla_pond_viol <- cartagena %>%
  group_by(household_survivor_violence) %>%
  summarise(n_pond = sum(f_exp_hog, na.rm = TRUE), .groups = "drop") %>%
  mutate(porc_pond = round(100 * n_pond / sum(n_pond), 1))

# 1.4 Unir tablas lado a lado 
tabla_comp_viol <- tabla_simple_viol %>%
  full_join(tabla_pond_viol, by = "household_survivor_violence") %>%
  arrange(household_survivor_violence)

# 1.5 Crear tabla HTML 
tabla8_viol <- tabla_comp_viol %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Hogar con sobrevivientes de violencia</b>",
    col.names = c("Hogar con sobrevivientes", "N (sin pond.)", "% (sin pond.)", "N (pond.)", "% (pond.)"),
    digits = 1
  ) %>%
  add_header_above(c(" " = 1, "Sin ponderar" = 2, "Ponderado" = 2)) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")

save_kable(tabla8_viol, "results/tabla8_household_survivor_violence.html")

# 2. Tabla para gráfico
tabla_grafico_viol <- tabla_comp_viol %>%
  select(household_survivor_violence, porc_sinpond, porc_pond) %>%
  pivot_longer(cols = c(porc_sinpond, porc_pond),
               names_to = "tipo", values_to = "porc") %>%
  mutate(
    tipo = ifelse(tipo == "porc_pond", "Ponderado", "Sin ponderar"),
    household_survivor_violence = factor(household_survivor_violence,
                                         levels = c(0, 1),
                                         labels = c("Sin sobrevivientes", "Con sobrevivientes"))
  )

# 2.1 Gráfico comparativo
grafico_viol <- ggplot(tabla_grafico_viol, aes(x = household_survivor_violence, y = porc, fill = tipo)) +
  geom_col(position = "dodge", alpha = 0.9) +
  geom_text(
    aes(label = paste0(porc, "%")),
    position = position_dodge(width = 0.9),
    vjust = -0.4,
    size = 3.5
  ) +
  scale_fill_manual(values = c("Sin ponderar" = "#999999", "Ponderado" = "#003366")) +
  labs(
    title = "Hogar con sobrevivientes de violencia",
    subtitle = "Comparación entre resultados sin ponderar y ponderados",
    x = "Condición del hogar",
    y = "Porcentaje de hogares",
    fill = "Tipo de cálculo"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

ggsave("results/grafico_household_survivor_violence.png", plot = grafico_viol, width = 10, height = 6, dpi = 300)

# 3. Notas de método
notas_metodo_viol <- "
Notas de método:
- La variable 'household_survivor_violence' identifica si en el hogar reside al menos una persona sobreviviente de violencia (1 = sí, 0 = no).
- La tabla presenta los conteos (N) y proporciones (%) sin ponderar y ponderados por el factor de expansión (f_exp_hog).
- Los valores ponderados reflejan la distribución ajustada a la población.
- La prevalencia de hogares con sobrevivientes de violencia es baja, pero representa un grupo prioritario de atención.
"

writeLines(notas_metodo_viol, "results/notas_metodo_household_survivor_violence.txt")

# 4. Calcular barras de error (IC 95%)
tabla_grafico_ic_viol <- tabla_comp_viol %>%
  mutate(
    p = porc_pond / 100,
    n = n_pond,
    se = sqrt(p * (1 - p) / n),
    ic_inf = 100 * (p - 1.96 * se),
    ic_sup = 100 * (p + 1.96 * se)
  )

# 4.1 Gráfico con barras de error
grafico_viol_ic <- ggplot(tabla_grafico_ic_viol, aes(
  x = factor(household_survivor_violence, labels = c("Sin sobrevivientes", "Con sobrevivientes")),
  y = porc_pond
)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_errorbar(aes(ymin = ic_inf, ymax = ic_sup), width = 0.2, color = "black") +
  geom_text(aes(label = paste0(round(porc_pond, 1), "%")),
            vjust = -0.4, size = 3.5, color = "black") +
  labs(
    title = "Hogar con sobrevivientes de violencia",
    subtitle = "Porcentaje ponderado con intervalos de confianza al 95%",
    x = "Condición del hogar",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0)
  )

print(grafico_viol_ic)

```



#### 5) Índice de vulnerabilidad

Explorando en detalle el índice de vulnerabilidad, definida como una variable categórica de 0 a 4, la cual indica la cantidad de vulnerabilidades con las que cuentan los hogares. 

```{r}
# 1. Tabla resumen
resumen_vul <- data.frame(
  Estadístico = c("N", "NAs", "Valores únicos", "Min.", "1st Qu.", "Median", "Mean", "3rd Qu.", "Max."),
  valor = c(
    sum(!is.na(cartagena_vul$vulnerability_score)),
    sum(is.na(cartagena_vul$vulnerability_score)),
    length(unique(cartagena_vul$vulnerability_score)),
    min(cartagena_vul$vulnerability_score, na.rm = TRUE),
    quantile(cartagena_vul$vulnerability_score, 0.25, na.rm = TRUE),
    median(cartagena_vul$vulnerability_score, na.rm = TRUE),
    mean(cartagena_vul$vulnerability_score, na.rm = TRUE),
    quantile(cartagena_vul$vulnerability_score, 0.75, na.rm = TRUE),
    max(cartagena_vul$vulnerability_score, na.rm = TRUE)
  )
)

# 1.2 Generar tabla
tabla_resumen_vul <- resumen_vul %>%
  kable(
    "html",
    caption = "<b style='color:#003366; font-size:16px;'>Variable: Puntaje de vulnerabilidad del hogar</b>"
  ) %>%
  kable_styling(
    full_width = FALSE,
    bootstrap_options = c("striped", "hover", "condensed"),
    position = "center"
  ) %>%
  row_spec(0, bold = TRUE, color = "white", background = "#003366")  # Encabezado azul oscuro

# 1.3 Guardar tabla
save_kable(tabla_resumen_vul, "results/resumen_vul.html")


# 2. Distribución de la variable
tabla_distrib_vul <- cartagena_vul %>%
  mutate(
    rango_vul = case_when(
      vulnerability_score < 0.25 ~ "Muy baja",
      vulnerability_score < 0.5  ~ "Baja",
      vulnerability_score < 0.75 ~ "Media",
      TRUE                       ~ "Alta"
    )
  ) %>%
  count(rango_vul) %>%
  mutate(porc = round(100 * n / sum(n), 1))

# 2.1 Gráfico
grafico_vul <- ggplot(tabla_distrib_vul, aes(x = rango_vul, y = porc)) +
  geom_col(fill = "#003366", alpha = 0.9) +
  geom_text(aes(label = paste0(porc, "%")), vjust = -0.3, size = 4, color = "black") +
  labs(
    title = "Distribución del puntaje de vulnerabilidad",
    subtitle = "Clasificación del nivel de vulnerabilidad de los hogares",
    x = "Nivel de vulnerabilidad",
    y = "Porcentaje de hogares"
  ) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),
    axis.text = element_text(size = 10),
    axis.title.x = element_text(size = 11, margin = margin(t = 10)),
    axis.title.y = element_text(size = 11, margin = margin(r = 10)),
    plot.title = element_text(face = "bold", size = 16, hjust = 0),
    plot.subtitle = element_text(size = 12, hjust = 0),
    plot.margin = unit(c(1, 1, 1, 1), "cm")
  )

# 2.2 Mostrar y guardar
print(grafico_vul)

ggsave("results/grafico_vul.png",
       plot = grafico_vul, width = 10, height = 6, dpi = 300)


# 3. Notas de método
notas_metodo_vul <- "
Notas de método:
- La variable 'vulnerability_score' corresponde a un puntaje continuo que mide el nivel de vulnerabilidad de los hogares.
- Los valores más altos indican mayor vulnerabilidad.
- Se validó que no existan valores fuera del rango esperado (0 a 1).
- Los valores NA se reportan explícitamente y no fueron imputados.
- No se aplican barras de error porque la variable es continua y se describe mediante estadísticos de tendencia central y dispersión.
"

writeLines(notas_metodo_vul, "results/notas_metodo_vul.txt")

```

Ahora con factor de expansión:
```{r}

```



# PARTE 3: Visualizaciones de exploración según la pregunta de indagación

Empezamos tratando las variable Y como continua y la variable X como categórica para la expliración inicial.

```{r}

# Definir diseño de encuesta con pesos
design <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena)

# Calcular medias por vulnerabilidad con IC95%
tabla_medias_pond2 <- svyby(~servicios, ~vulnerability_score, design, svymean, vartype = c("ci"))

# Gráfico
grafico_pond2 <- ggplot(tabla_medias_pond2, aes(x = as.factor(vulnerability_score), y = servicios)) +
  geom_col(fill = "#003366", alpha = 0.8) +
  geom_errorbar(aes(ymin = ci_l, ymax = ci_u), width = 0.2, color = "#e41a1c") +
  geom_text(aes(label = round(servicios, 2)), vjust = -0.5, size = 3.5, color = "black") +
  labs(
    title = "Media de servicios faltantes según vulnerabilidad",
    subtitle = "Cartagena de Indias – ponderado con factor de expansión",
    x = "Índice de vulnerabilidad (0–4)",
    y = "Promedio ponderado de servicios faltantes", 
    caption = "Nota: Para la construcción del gráfico se usó el factor de expansión para hogares. "
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )

print(grafico_pond2)

```

Es posible que esta estrategia no sea tan adecuada porque es posible que la distribución de la variable de carencia de servicios no siga una distribución normal y esto afecte negativamente la visualización de los datos. De esta manera, se considera quye una opción puede ser revisar la proporción de hogares con carencia de 2 o más servicios (dicotomizar la variable de carencia de servicios) y visualizar esta variable para cada una de las condiciones de vulnerabilidad. Este análisis tiene relevancia ya que es posible que las diferentes condiciones evaluadas no tengan la misma ponderación al analizar la variable latente "vulnerabilidad".

```{r}
# Objeto de diseño de encuesta
design <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena)

# Seleccionando las variables
vars <- c("head_female",
          "single_parent_relaxed",
          "household_has_disability",
          "household_survivor_violence")

# Función: media ponderada de `servicios` por nivel de cada variable (IC95%)
res_list <- map(vars, function(v){
  f <- reformulate(v)                     
  out <- svyby(~servicios, f, design,
               svymean, vartype = c("ci"), na.rm = TRUE, keep.names = FALSE)
  names(out)[names(out) == "servicios"] <- "mean"
  out$var   <- v
  names(out)[names(out) == v] <- "level"   
  out
})

res <- bind_rows(res_list) %>%
  mutate(
    var = case_match(var,
      "head_female"               ~ "Jefatura femenina",
      "single_parent_relaxed"     ~ "Hogar monoparental",
      "household_has_disability"  ~ "Con discapacidad en el hogar",
      "household_survivor_violence" ~ "Antecedente de violencia"
    ),
    level = factor(level, levels = c(0,1), labels = c("No","Sí"))
  )

# Gráfico
g_comp <- ggplot(res, aes(x = level, y = mean)) +
  geom_col(fill = "#003366", alpha = 0.85) +
  geom_errorbar(aes(ymin = ci_l, ymax = ci_u), width = 0.15, color = "#e41a1c") +
  geom_text(aes(label = round(mean, 2)), vjust = -0.6, size = 3.3) +
  facet_wrap(~ var, nrow = 1) +
  labs(
    title = "Carencias de servicios por componentes de vulnerabilidad",
    subtitle = "Cartagena de Indias – promedio ponderado de servicios faltantes (0–5) con IC95%",
    x = NULL,
    y = "Promedio ponderado de servicios faltantes",
    caption = "Ponderado por f_exp_hog. Barras = E[servicios|X], líneas = IC95%."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    panel.grid = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.caption = element_text(hjust = 0)
  )

print(g_comp)

```

Revisando todas las gráficas previas del bivariado, nos dimos cuenta que estabamos usando la variable de carencia de servicios como continua y al final la codificación que usamos puede que actue más como una variable categórica y por esta razón decidimos hacer una exploración inicial de cada variable poniendo un punto de corte de 2 servicios carentes o más.

```{r}
# Creando una copia del df oringial.
cartagena_tmp <- cartagena %>%
  mutate(falta_mas1 = as.integer(servicios >= 2)) 

# Objeto de diseño de encuesta para usar el factor de expansión
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# función para dar formato
nice_pct <- function(x) sprintf("%.1f%%", 100*x)

# Función para calcular y graficar 
make_prop_plot <- function(var, var_label, file_out, des){
  fml <- reformulate(var)
  out <- svyby(~falta_mas1, fml, des, svymean,
               vartype = c("ci"), na.rm = TRUE, keep.names = FALSE)

  names(out)[names(out) == "falta_mas1"] <- "prop"
  names(out)[names(out) == var] <- "level"

  df <- out %>%
    mutate(
      level = factor(level, levels = c(0,1), labels = c("No","Sí")),
      prop_lab = nice_pct(prop)
    )

  g <- ggplot(df, aes(x = level, y = prop)) +
    geom_col(fill = "#003366", alpha = 0.9) +
    geom_errorbar(aes(ymin = ci_l, ymax = ci_u),
                  width = 0.18, color = "#e41a1c") +
    geom_text(aes(label = prop_lab), vjust = -0.6, size = 3.5) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
    labs(
      title = paste0("Hogares con >1 servicio faltante por ", var_label),
      subtitle = "Proporción ponderada (IC95%) – Cartagena de Indias",
      x = var_label,
      y = "Proporción de hogares",
      caption = "Ponderado por f_exp_hog. Indicador: servicios ≥ 2."
    ) +
    theme_minimal(base_size = 12) +
    theme(
      panel.grid = element_blank(),
      plot.caption = element_text(hjust = 0)
    )

  print(g)
}

# Ejecutando la función para cada variable de interés. 
make_prop_plot("head_female",
               "Jefatura femenina",
               "results/figures/prop_mas1_head_female.png",
               des_tmp)

make_prop_plot("single_parent_relaxed",
               "Hogar monoparental",
               "results/figures/prop_mas1_single_parent.png",
               des_tmp)

make_prop_plot("household_has_disability",
               "Con discapacidad en el hogar",
               "results/figures/prop_mas1_disability.png",
               des_tmp)

make_prop_plot("household_survivor_violence",
               "Antecedente de violencia",
               "results/figures/prop_mas1_violence.png",
               des_tmp)


```

```{r}
# preparación de datos
cartagena_tmp <- cartagena %>%
  mutate(falta_mas1 = as.integer(servicios >= 2))

# objeto de Diseño ponderado
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# Seleccionando Variables binarias a comparar
vars <- c("household_has_disability",
          "head_female",
          "single_parent_relaxed",
          "household_survivor_violence")

# Dejando la categoría de Sí
res_list <- lapply(vars, function(v){
  fml <- reformulate(v)  # ~ var
  out <- svyby(~falta_mas1, fml, des_tmp, svymean, na.rm = TRUE, keep.names = FALSE)
  names(out)[names(out) == "falta_mas1"] <- "prop"
  names(out)[names(out) == v] <- "level"
  out$var <- v
  out
})

res <- bind_rows(res_list) %>%
  filter(level == 1) %>%
  mutate(
    var_label = case_when(
      var == "household_has_disability"    ~ "Con discapacidad en el hogar",
      var == "head_female"                 ~ "Jefatura femenina",
      var == "single_parent_relaxed"       ~ "Hogar monoparental",
      var == "household_survivor_violence" ~ "Antecedente de violencia",
      TRUE ~ var
    )
  ) %>%
  select(var_label, prop)

# Proporción cuando NO hay ninguna condición de vulnerabilidad
prop_none <- as.numeric(
  svymean(~falta_mas1,
          subset(des_tmp,
                 household_has_disability == 0 &
                 head_female == 0 &
                 single_parent_relaxed == 0 &
                 household_survivor_violence == 0),
          na.rm = TRUE)
)

ref_row <- tibble(
  var_label = "Ninguna condición de vulnerabilidad",
  prop = prop_none
)

# Reajustando el df para el gráfico
res2 <- bind_rows(res, ref_row) %>%
  mutate(
    prop_lab = paste0(round(100 * prop, 1), "%")
  ) %>%
  arrange(desc(prop)) %>%
  mutate(var_label = factor(var_label, levels = rev(var_label)))  # orden descendente

# Haciendo el gráfico
g_all <- ggplot(res2, aes(y = var_label, x = prop)) +
  geom_col(fill = "#003366", alpha = 0.9, width = 0.7) +
  geom_text(aes(label = prop_lab), hjust = -0.15, size = 3.8, color = "black") +
  scale_x_continuous(labels = scales::percent_format(accuracy = 1),
                     limits = c(0, max(res2$prop) * 1.08)) +
  labs(
    title = "Hogares migrantes venezolanos con carencia en alguno de los servicios básicos en Cartagena",
    subtitle = "Comparación por condición específica de vulnerabilidad",
    y = NULL,
    caption = "Nota: Para la construcción del gráfico se usó el factor de expansión para hogares"
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )
print(g_all)

```

Ahora que sabemos que la proporción de hogares con carencia de dos servicios o más sí difiere para las diferentes condiciones de vulnerabilidad, vamos a averiguar si está relación se mantiene cuando agregamos estás condiciones en un solo indicador de vulnerabildiad.

```{r}
# Preparando los datos
cartagena_tmp <- cartagena %>%
  mutate(
    falta_mas1 = as.integer(servicios >= 2),
    vuln = suppressWarnings(as.numeric(as.character(vulnerability_score)))
  )

# Diseño ponderado
des_tmp <- svydesign(ids = ~1, weights = ~f_exp_hog, data = cartagena_tmp)

# Proporción ponderada por índice de vulnerabilidad
out <- svyby(~falta_mas1, ~vuln, des_tmp, svymean, na.rm = TRUE, keep.names = FALSE)

# Preparando los datos
df_vul <- out %>%
  rename(prop = falta_mas1, score = vuln) %>%
  filter(!is.na(score), score %in% 0:4) %>%
  arrange(score) %>%
  mutate(
    score_f = factor(score, levels = 0:4, labels = c("0","1","2","3","4")),
    prop_lab = paste0(round(100*prop, 1), "%")
  )

# Creando el gráfico
g_vul <- ggplot(df_vul, aes(x = score_f, y = prop)) +
  geom_col(fill = "#003366", alpha = 0.9, width = 0.6) + 
  geom_text(aes(label = prop_lab), vjust = -0.6, size = 3.8, color = "black") +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1),
                     limits = c(0, max(df_vul$prop) * 1.15)) +
  labs(
    title = "Hogares migrantes venezolanos con ≥2 servicios faltantes según índice de vulnerabilidad en Cartagena",
    x = "Índice de vulnerabilidad (0–4)",
    y = "Proporción de hogares",
    caption = "Ponderado por f_exp_hog. Indicador: servicios faltantes ≥ 2."
  ) +
  theme_minimal(base_size = 12) +
  theme(
    plot.caption = element_text(hjust = 0, size = 8, color = "grey45"), 
    plot.caption.position = "plot"  
  )

print(g_vul)

```

Debido a que a primera vista la gráfica puede resultar poco clara(intentamos mostrarle esta gráfica a personas cercanas que no concían el problema para ver qué mensaje transmitía la gráfica), entonces probamos otra forma de visualizar la misma información.

```{r}
df <- res2 %>% 
  mutate(var_label = factor(var_label, levels = rev(var_label)))

ggplot(df, aes(x = prop, y = var_label)) +
  geom_point(size = 3) +
  geom_errorbarh(aes(xmin = prop - 1.96*sqrt(prop*(1-prop)/1000), 
                     xmax = prop + 1.96*sqrt(prop*(1-prop)/1000)), height = 0) +
  scale_x_continuous(labels = scales::percent) +
  labs(title = "Proporción con ≥2 carencias por condición",
       x = "Proporción ponderada", y = NULL,
       caption = "Cleveland dot-plot: prioriza posición sobre área.") +
  theme_minimal()

```

Considerando que no estaba muy contento con la visualización hasta este punto porque no lograba transmitir todas las posibilidades de carencia de servicios a través de todos los níveles nueva vulnerabilidad, decidimos hacer un grafico de barras apiladas de la carencia de servicios por cada una de las categorías del índice de vulnerabilidad que resultó mucho mejor y nos permitía ver mucho mejor la relación y responder la pregunta.

```{r}


# Preparación de datos 
df_plot <- cartagena %>%
  mutate(
    servicios = as.integer(servicios),
    vuln = as.integer(as.character(vulnerability_score))
  )

# Creando el objeto de Diseño Muestral Ponderado
des <- svydesign(ids = ~1, weights = ~f_exp_hog, data = df_plot)

# Tabla de Proporciones Ponderadas 
tab_w <- as.data.frame(svytable(~ servicios + vuln, design = des)) %>%
  as_tibble() %>% 
  rename(nw = Freq) %>%
  group_by(vuln) %>%
  mutate(prop = nw / sum(nw)) %>%
  ungroup() %>%
  mutate(
    servicios = factor(servicios, levels = 4:0, labels = c("4", "3", "2", "1", "0")),
    vuln      = factor(vuln, levels = 0:4, labels = c("0", "1", "2", "3", "4")),
    prop_lab  = paste0(round(100 * prop, 1), "%")
  )

#Haciendo el gráfico
g_stack_final_simple <- ggplot(tab_w, aes(x = vuln, y = prop, fill = servicios)) +
  geom_hline(yintercept = 0, color = "gray70", linetype = "solid") +
  geom_col(width = 0.8) +
  geom_text(
    data = ~ filter(.x, prop >= 0.05),
    aes(
      label = prop_lab,
      color = ifelse(servicios == "4", "especial", "normal")  
    ),
    position = position_stack(vjust = 0.5),
    size = 3.5,
    fontface = "bold",
    show.legend = FALSE
  ) +
  scale_y_continuous(
    labels = percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_brewer(
    palette = "Blues",
    direction = -1,
    name = "Número de Carencias:"
  ) +
  scale_color_manual(  
    values = c("normal" = "gray20", "especial" = "white")  
  ) +
  labs(
    title = "Distribución porcentual de hogares según la vulnerabilidad\ny el número de carencias en servicios básicos",
    x = "Índice de Vulnerabilidad del hogar",
    y = "Proporción de hogares",
    caption = "Nota: Proporciones ponderadas con el factor de expansión del hogar (f_exp_hog).\nEl índice de vulnerabilidad va de 0 (sin condiciones) a 3 (tres condiciones de vulnerabilidad)."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold", size = rel(1.2)),
    plot.caption = element_text(hjust = 0, color = "gray40"),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10))
  )

print(g_stack_final_simple)

# exportando el gráfico
ggsave(
  filename = "results/figures/grafico11_servicios_VulScore_stacked.png",
  plot = g_stack_final_simple,
  width = 10,
  height = 7,
  dpi = 300,
  bg = "white"
)
```

Ahora vamos a hacer la misma gráfica pero intentando presentar como se comporta la carencia de servicios para cada una de las condiciones consideradas como de vulnerabilidad:

```{r}
# --------------------------------
# AJUSTANDO LOS DATOS PARA HACER LA GRÁFICA QUE QUEREMOS

# Definimos las variables de vulnerabilidad que vamos a analizar.
vars_vulnerabilidad <- c(
  "head_female", 
  "single_parent_relaxed", 
  "household_has_disability", 
  "household_survivor_violence"
)

# Creamos el data.frame largo, ideal para ggplot2.
df_largo <- cartagena %>%
  # Nos aseguramos de que las variables de vulnerabilidad sean numéricas (0 o 1)
  mutate(across(all_of(vars_vulnerabilidad), as.integer)) %>%
  
  # Creamos la categoría "Sin Vulnerabilidad".
  # Será 1 si la suma de todas las vulnerabilidades es 0.
  mutate(
    sin_vulnerabilidad = if_else(rowSums(select(., all_of(vars_vulnerabilidad))) == 0, 1, 0)
  ) %>%
  
  # Pivotamos los datos de formato ancho a largo.
  # Cada hogar tendrá ahora múltiples filas, una por cada condición de vulnerabilidad.
  tidyr::pivot_longer(
    cols = c(all_of(vars_vulnerabilidad), "sin_vulnerabilidad"),
    names_to = "grupo_vulnerabilidad",
    values_to = "presente"
  ) %>%
  
  # Filtramos para quedarnos solo con las condiciones que el hogar SÍ presenta.
  # Esto evita duplicar hogares en el conteo.
  filter(presente == 1) %>%
  
  # Limpiamos y ordenamos las etiquetas para el gráfico.
  mutate(
    grupo_vulnerabilidad = fct_recode(
      grupo_vulnerabilidad,
      "Sin Vulnerabilidad" = "sin_vulnerabilidad",
      "Jefatura Femenina" = "head_female",
      "Monoparental" = "single_parent_relaxed",
      "Con Discapacidad" = "household_has_disability",
      "Víctima de Violencia" = "household_survivor_violence"
    ),
    # Reordenamos los niveles para que "Sin Vulnerabilidad" aparezca primero.
    grupo_vulnerabilidad = fct_relevel(
      grupo_vulnerabilidad, 
      "Sin Vulnerabilidad", "Jefatura Femenina", "Monoparental", "Con Discapacidad"
    )
  )

# --------------------------------
# PREPARANDO EL DF PARA EL GRÁFICO

# Creamos el objeto de diseño muestral con los datos ya transformados.
des_largo <- svydesign(ids = ~1, weights = ~f_exp_hog, data = df_largo)

# Calculamos la tabla de proporciones ponderadas.
datos_grafico <- as.data.frame(svytable(~ servicios + grupo_vulnerabilidad, design = des_largo)) %>%
  as_tibble() %>%
  rename(conteo_pond = Freq) %>%
  group_by(grupo_vulnerabilidad) %>%
  mutate(proporcion = conteo_pond / sum(conteo_pond)) %>%
  ungroup() %>%
  mutate(
    # Ordenamos 'servicios' para el apilamiento (4 carencias arriba)
    servicios = factor(servicios, levels = 4:0),
    # Creamos la etiqueta de texto
    etiqueta_prop = paste0(round(100 * proporcion, 1), "%")
  )


# --------------------------------
# HACIENDO EL GRÁFICO

g_stack_final <- ggplot(datos_grafico, aes(x = grupo_vulnerabilidad, y = proporcion, fill = servicios)) +
  geom_hline(yintercept = 0, color = "gray70", linetype = "solid") +
  geom_col(width = 0.7) + 
  geom_text(
    data = ~ filter(.x, proporcion >= 0.02),
    aes(
      label = etiqueta_prop,
      color = ifelse(servicios == "4", "especial", "normal") 
    ),
    position = position_stack(vjust = 0.5),
    size = 3.5,
    fontface = "bold",
    show.legend = FALSE
  ) +
  scale_y_continuous(
    labels = scales::percent_format(accuracy = 1),
    expand = expansion(mult = c(0, 0.05))
  ) +
  scale_fill_brewer(
    palette = "Blues",
    direction = -1,
    name = "Número de Carencias:"
  ) +
  scale_color_manual(values = c("normal" = "gray20", "especial" = "white")) +
  labs(
    title = "Distribución de carencias en servicios por condición de vulnerabilidad del hogar",
    x = "Condición de vulnerabilidad",
    y = "Proporción de hogares",
    caption = "Nota: Proporciones ponderadas con el factor de expansión del hogar (f_exp_hog)."
  ) +
  theme_minimal(base_size = 14) +
  theme(
    panel.grid.major.x = element_blank(),
    panel.grid.minor = element_blank(),
    legend.position = "top",
    plot.title = element_text(hjust = 0.5, face = "bold", size = rel(1.2)),
    plot.caption = element_text(hjust = 0, color = "gray40"),
    axis.title.y = element_text(margin = margin(r = 10)),
    axis.title.x = element_text(margin = margin(t = 10)),
    axis.text.x = element_text(angle = 15, hjust = 1) 
  )

print(g_stack_final)

# --------------------------------
# EXPORTANDO EL GRÁFICO
ggsave(
  filename = "results/figures/grafico12_servicios_por_condicion_final.png",
  plot = g_stack_final,
  width = 11,
  height = 8,
  dpi = 300,
  bg = "white"
)
```

# PARTE 4:Evidencia empírica y estimación
1. Describa el diseño del contraste estadísJco
1. Seleccione la prueba de acuerdo con la situación (por ejemplo, prueba t de
diferencia de medias, prueba de proporciones, etc.)
2. Explique brevemente qué se está comparando y cuál sería la expectaJva teórica o
empírica según el hecho esJlizado que se desea comprobar.
3. Señale si el contraste es bilateral o unilateral y cuál sería la dirección esperada del
efecto. Esto en línea con lo encontrado en el EDA
2. Revise los supuestos y ejecute la prueba
1. Verifique las condiciones necesarias para aplicar la prueba elegida (normalidad,
independencia, homogeneidad de varianzas, tamaño de muestra). En caso de que
alguna condición no se cumpla, jusJfique la prueba alternaJva empleada o las
transformaciones realizadas sobre los datos.
2. Ejecute la prueba y reporte los resultados relevantes: estadísJco de prueba, el
intervalo de confianza esJmado.
3. Reporte el p-valor de la prueba de hipótesis y explique qué significa en términos del
riesgo de error Jpo I.