forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
kableExtra,
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr         # Generación de reportes dinámicos.
)
# 1. Calcular frecuencias ponderadas para vulnerability_score (X)
freq_vulnerabilidad_pond <- cartagena %>%
group_by(vulnerability_score) %>%
summarise(
Frecuencia_Ponderada = sum(f_exp_hog)
) %>%
ungroup() %>%
# Añadir la columna de Proporción Ponderada (%)
mutate(Proporcion_Ponderada = Frecuencia_Ponderada / sum(Frecuencia_Ponderada) * 100) %>%
rename(`Índice de Vulnerabilidad` = vulnerability_score)
# 2. Determinar la Proporción máxima de empates PONDERADOS
max_prop_v_pond <- max(freq_vulnerabilidad_pond$Proporcion_Ponderada) / 100
# 3. Generar la tabla con el formato kableExtra
tabla_vulnerabilidad <- freq_vulnerabilidad_pond %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Frecuencia Ponderada: Índice de Vulnerabilidad</b>",
digits = 2 # Redondea los valores a 2 decimales
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366") # <-- Encabezado azul oscuro
# 4. Exportar la tabla
file_vulnerabilidad <- file.path(output_dir, "tabla_vulnerabilidad_ponderada.html")
# 1. Calcular frecuencias ponderadas para vulnerability_score (X)
freq_vulnerabilidad_pond <- cartagena %>%
group_by(vulnerability_score) %>%
summarise(
Frecuencia_Ponderada = sum(f_exp_hog)
) %>%
ungroup() %>%
# Añadir la columna de Proporción Ponderada (%)
mutate(Proporcion_Ponderada = Frecuencia_Ponderada / sum(Frecuencia_Ponderada) * 100) %>%
rename(`Índice de Vulnerabilidad` = vulnerability_score)
# 2. Determinar la Proporción máxima de empates PONDERADOS
max_prop_v_pond <- max(freq_vulnerabilidad_pond$Proporcion_Ponderada) / 100
# 3. Generar la tabla con el formato kableExtra
tabla_vulnerabilidad <- freq_vulnerabilidad_pond %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Frecuencia Ponderada: Índice de Vulnerabilidad</b>",
digits = 2 # Redondea los valores a 2 decimales
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366") # <-- Encabezado azul oscuro
# 4. Exportar la tabla
file_vulnerabilidad <- "results/tabla_vulnerabilidad_ponderada.html")
# 4. Exportar la tabla
file_vulnerabilidad <- "results/tabla_vulnerabilidad_ponderada.html"
cat(sprintf("Tabla de Vulnerabilidad Ponderada exportada a: %s\n", file_vulnerabilidad))
cat(sprintf("Proporción máxima de empates PONDERADOS en X: %.2f%%\n", max_prop_v_pond * 100))
# 1. Calcular frecuencias ponderadas para vulnerability_score (X)
freq_vulnerabilidad_pond <- cartagena %>%
group_by(vulnerability_score) %>%
summarise(
Frecuencia_Ponderada = sum(f_exp_hog)
) %>%
ungroup() %>%
# Añadir la columna de Proporción Ponderada (%)
mutate(Proporcion_Ponderada = Frecuencia_Ponderada / sum(Frecuencia_Ponderada) * 100) %>%
rename(`Índice de Vulnerabilidad` = vulnerability_score)
# 2. Determinar la Proporción máxima de empates PONDERADOS
max_prop_v_pond <- max(freq_vulnerabilidad_pond$Proporcion_Ponderada) / 100
# 3. Generar la tabla con el formato kableExtra
tabla_vulnerabilidad <- freq_vulnerabilidad_pond %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Frecuencia Ponderada: Índice de Vulnerabilidad</b>",
digits = 2 # Redondea los valores a 2 decimales
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366") # <-- Encabezado azul oscuro
# 4. Exportar la tabla
file_vulnerabilidad <- "results/tabla_vulnerabilidad_ponderada.html"
save_kable(tabla_vulnerabilidad, file_vulnerabilidad)
cat(sprintf("Tabla de Vulnerabilidad Ponderada exportada a: %s\n", file_vulnerabilidad))
cat(sprintf("Proporción máxima de empates PONDERADOS en X: %.2f%%\n", max_prop_v_pond * 100))
# --- B. CÁLCULO DE FRECUENCIAS PONDERADAS Y EXPORTACIÓN - NÚMERO DE CARENCIA (Y) ---
# 1. Calcular frecuencias ponderadas para servicios (Y)
freq_carencias_pond <- cartagena %>%
group_by(servicios) %>%
summarise(
Frecuencia_Ponderada = sum(f_exp_hog)
) %>%
ungroup() %>%
# Añadir la columna de Proporción Ponderada (%)
mutate(Proporcion_Ponderada = Frecuencia_Ponderada / sum(Frecuencia_Ponderada) * 100) %>%
rename(`Número de Carencias` = servicios)
# 2. Determinar la Proporción máxima de empates PONDERADOS
max_prop_c_pond <- max(freq_carencias_pond$Proporcion_Ponderada) / 100
# 3. Generar la tabla con el formato kableExtra
tabla_carencias <- freq_carencias_pond %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Frecuencia Ponderada: Número de Carencias (Servicios)</b>",
digits = 2
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366") # <-- Encabezado azul oscuro
# 4. Exportar la tabla
file_carencias <- "results/tabla_carencias_ponderada.html")
# --- B. CÁLCULO DE FRECUENCIAS PONDERADAS Y EXPORTACIÓN - NÚMERO DE CARENCIA (Y) ---
# 1. Calcular frecuencias ponderadas para servicios (Y)
freq_carencias_pond <- cartagena %>%
group_by(servicios) %>%
summarise(
Frecuencia_Ponderada = sum(f_exp_hog)
) %>%
ungroup() %>%
# Añadir la columna de Proporción Ponderada (%)
mutate(Proporcion_Ponderada = Frecuencia_Ponderada / sum(Frecuencia_Ponderada) * 100) %>%
rename(`Número de Carencias` = servicios)
# 2. Determinar la Proporción máxima de empates PONDERADOS
max_prop_c_pond <- max(freq_carencias_pond$Proporcion_Ponderada) / 100
# 3. Generar la tabla con el formato kableExtra
tabla_carencias <- freq_carencias_pond %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Frecuencia Ponderada: Número de Carencias (Servicios)</b>",
digits = 2
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366") # <-- Encabezado azul oscuro
# 4. Exportar la tabla
file_carencias <- "results/tabla_carencias_ponderada.html"
save_kable(tabla_carencias, file_carencias)
cat(sprintf("Tabla de Carencias Ponderada exportada a: %s\n", file_carencias))
cat(sprintf("Proporción máxima de empates PONDERADOS en Y: %.2f%%\n", max_prop_c_pond * 100))
# ------------------------------------------------------------------------
# B. ESTRUCTURA DE LA RELACIÓN (SUPUESTO B)
# ------------------------------------------------------------------------
# 1. Matriz de Frecuencia Ponderada (Suma de Pesos Ponderados)
matriz_frecuencia_ponderada <- xtabs(f_exp_hog ~ vulnerability_score + servicios, data = cartagena)
# Convertir la matriz a data frame para kableExtra
df_matriz <- as.data.frame.matrix(matriz_frecuencia_ponderada)
df_matriz$vulnerability_score <- rownames(df_matriz)
df_matriz <- df_matriz %>% relocate(vulnerability_score)
# 2. Generar la tabla HTML
tabla_matriz_frecuencia <- df_matriz %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Matriz de Frecuencia Ponderada (vulnerability_score vs. servicios)</b>",
digits = 2
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366")
# 3. Exportar la tabla
file_matriz <- "file.path(output_dir, ""results/tabla_matriz_frecuencia_ponderada.html"
# ------------------------------------------------------------------------
# B. ESTRUCTURA DE LA RELACIÓN (SUPUESTO B)
# ------------------------------------------------------------------------
# 1. Matriz de Frecuencia Ponderada (Suma de Pesos Ponderados)
matriz_frecuencia_ponderada <- xtabs(f_exp_hog ~ vulnerability_score + servicios, data = cartagena)
# Convertir la matriz a data frame para kableExtra
df_matriz <- as.data.frame.matrix(matriz_frecuencia_ponderada)
df_matriz$vulnerability_score <- rownames(df_matriz)
df_matriz <- df_matriz %>% relocate(vulnerability_score)
# 2. Generar la tabla HTML
tabla_matriz_frecuencia <- df_matriz %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Matriz de Frecuencia Ponderada (vulnerability_score vs. servicios)</b>",
digits = 2
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366")
# 3. Exportar la tabla
file_matriz <- "results/tabla_matriz_frecuencia_ponderada.html"
save_kable(tabla_matriz_frecuencia, file_matriz)
View(df_matriz)
# ------------------------------------------------------------------------
# B. ESTRUCTURA DE LA RELACIÓN (SUPUESTO B)
# ------------------------------------------------------------------------
# 1. Matriz de Frecuencia Ponderada (Suma de Pesos Ponderados)
matriz_frecuencia_ponderada <- xtabs(f_exp_hog ~ vulnerability_score + servicios, data = cartagena)
# Convertir la matriz a data frame para kableExtra
df_matriz <- as.data.frame.matrix(matriz_frecuencia_ponderada)
df_matriz$vulnerability_score <- rownames(df_matriz)
df_matriz <- df_matriz %>% relocate(vulnerability_score)
# 2. Generar la tabla HTML
tabla_matriz_frecuencia <- df_matriz %>%
kable(
"html",
caption = "<b style='color:#003366; font-size:16px;'>Matriz de Frecuencia Ponderada (vulnerability_score vs. servicios)</b>",
digits = 2,
row.names = FALSE
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed"),
position = "center"
) %>%
row_spec(0, bold = TRUE, color = "white", background = "#003366")
# 3. Exportar la tabla
file_matriz <- "results/tabla_matriz_frecuencia_ponderada.html"
save_kable(tabla_matriz_frecuencia, file_matriz)
# ------------------------------------------------------------------------
# C. CÁLCULO DE RHO DE SPEARMAN PONDERADO (SUPUESTOS A, C y D)
# ------------------------------------------------------------------------
cat("\n### C. Rho de Spearman Ponderado (Estadístico de Prueba) ###\n\n")
# Usamos weightedCorr para obtener el coeficiente ajustado por los pesos
resultado_spearman <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman",
weights = cartagena$f_exp_hog
)
cat(sprintf("Resultado del Rho de Spearman PONDERADO: %.4f\n", resultado_spearman))
### Bloque de R Markdown: Bootstrapping para p-value e IC
# Cargar la librería necesaria
library(wCorr)
cat("\n### D. Cálculo Final de Inferencia (p-value e IC) ###\n\n")
cat("Nota: Este cálculo usa 1000 repeticiones de Bootstrapping y puede tardar varios segundos.\n")
# Ejecución del weightedCorr con método boot para obtener el p-value e IC
resultado_completo <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman",
weights = cartagena$f_exp_hog,
boot_method = "boot",      # Activa el bootstrapping
boot_replication = 1000    # Número de repeticiones para la precisión
)
# Ejecución del weightedCorr con método boot para obtener el p-value e IC
resultado_completo <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman",
weights = cartagena$f_exp_hog,
bootstraps = 1000
)
# Ejecución del weightedCorr con método boot para obtener el p-value e IC
resultado_completo <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman",
weights = cartagena$f_exp_hog,
boot.iter = 1000
)
### Bloque de R Markdown: Cálculo Final de Inferencia con Librería 'survey'
# Cargar las librerías necesarias
# install.packages("survey")
library(survey)
cat("\n### D. Cálculo Final de Inferencia (p-value e IC) - Método Survey ###\n\n")
# 1. Crear el objeto de diseño de la encuesta (svydesign)
# Solo usamos 'weights' (pesos). Si tienes 'ids' (conglomerados) o 'strata' (estratos), deberías incluirlos.
svy_design <- svydesign(
ids = ~1,             # ids=~1: Asume muestreo aleatorio simple dentro de las estratos (o sin conglomerados)
weights = ~f_exp_hog, # Usamos tu factor de expansión
data = cartagena
)
# 2. Calcular la correlación de Spearman ponderada y su varianza ajustada
# NOTA: La librería 'survey' calcula la CORRELACIÓN DE PEARSON sobre los datos, pero
#      para obtener Spearman, debemos calcular Pearson sobre los RANGOS.
# a. Crear nuevas variables con los rangos (maneja los empates automáticamente)
cartagena$rank_vulnerability <- rank(cartagena$vulnerability_score, ties.method = "average")
cartagena$rank_servicios <- rank(cartagena$servicios, ties.method = "average")
# b. Actualizar el objeto de diseño con las nuevas variables de rango
svy_design <- update(svy_design,
rank_vulnerability = rank_vulnerability,
rank_servicios = rank_servicios)
# a. Crear nuevas variables con los rangos (maneja los empates automáticamente)
cartagena$rank_vulnerability <- rank(cartagena$vulnerability_score, ties.method = "average")
cartagena$rank_servicios <- rank(cartagena$servicios, ties.method = "average")
# b. Actualizar el objeto de diseño con las nuevas variables de rango
svy_design <- update(svy_design,
rank_vulnerability = cartagena$rank_vulnerability,
rank_servicios = cartagena$rank_servicios)
rho_ponderado_final <- svycor(~rank_vulnerability + rank_servicios,
design = svy_design)
# ------------------------------------------------------------------------
# C. CÁLCULO DE RHO DE SPEARMAN PONDERADO (SUPUESTOS A, C y D)
# ------------------------------------------------------------------------
cat("\n### C. Rho de Spearman Ponderado (Estadístico de Prueba) ###\n\n")
# Usamos weightedCorr para obtener el coeficiente ajustado por los pesos
resultado_spearman <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman"
)
cat(sprintf("Resultado del Rho de Spearman PONDERADO: %.4f\n", resultado_spearman))
# Paquetes ---------------------------------------------------------------
if (!requireNamespace("wCorr", quietly = TRUE)) install.packages("wCorr")
library(wCorr)
# --- ENTRADAS (ajusta nombres si cambian) ------------------------------
x <- cartagena$vulnerability_score
y <- cartagena$servicios
w <- cartagena$f_exp_hog
# Limpieza: casos completos y pesos positivos ---------------------------
keep <- is.finite(x) & is.finite(y) & is.finite(w) & w > 0
x <- x[keep]; y <- y[keep]; w <- w[keep]
# Normalizo pesos para muestreos (no afecta el coeficiente en sí) -------
w_prob <- w / sum(w)
n <- length(x)
# 1) Rho de Spearman ponderado (observado) -------------------------------
rho_obs <- wCorr::weightedCorr(x, y, method = "Spearman", weights = w)
# 2) IC por bootstrap ponderado -----------------------------------------
boot_weighted_spearman <- function(x, y, w, w_prob, R = 2000, seed = 123){
if(!is.null(seed)) set.seed(seed)
n <- length(x)
boots <- replicate(R, {
idx <- sample.int(n, replace = TRUE, prob = w_prob)
wCorr::weightedCorr(x[idx], y[idx], method = "Spearman", weights = w[idx])
})
ci <- stats::quantile(boots, c(0.025, 0.975), na.rm = TRUE)
list(boots = boots, ci = ci)
}
boot_res <- boot_weighted_spearman(x, y, w, w_prob, R = 2000, seed = 123)
ci_boot <- boot_res$ci
# 3) p-value por permutación (H0: independencia; ρ = 0) -----------------
perm_pvalue <- function(x, y, w, R = 10000, seed = 456){
if(!is.null(seed)) set.seed(seed)
obs <- wCorr::weightedCorr(x, y, method = "Spearman", weights = w)
perms <- replicate(R, {
y_perm <- sample(y, replace = FALSE)
wCorr::weightedCorr(x, y_perm, method = "Spearman", weights = w)
})
p_two_sided <- (sum(abs(perms) >= abs(obs)) + 1) / (R + 1)
list(p = p_two_sided, perms = perms, obs = obs)
}
perm_res <- perm_pvalue(x, y, w, R = 10000, seed = 456)
p_perm <- perm_res$p
# 4) (Opcional) Aproximación analítica rápida con n_eff ------------------
#    Útil como chequeo; ignora diseño complejo. Para Spearman se usa
#    un z-transform con var ≈ 1.06/(n_eff - 3) (Bonett & Wright, 2000).
n_eff <- (sum(w)^2) / sum(w^2)
z_s  <- 0.5 * log((1 + rho_obs) / (1 - rho_obs))
se_z <- sqrt(1.06 / pmax(n_eff - 3, 1.0001))  # evita división por ~0
zstat <- z_s / se_z
p_norm <- 2 * (1 - pnorm(abs(zstat)))
ci_z   <- z_s + c(-1, 1) * qnorm(0.975) * se_z
ci_ana <- tanh(ci_z)
# Salida legible ---------------------------------------------------------
cat("\n### C. Rho de Spearman Ponderado (Estadístico de Prueba) ###\n\n")
cat(sprintf("Rho ponderado (observado): %.4f\n", rho_obs))
cat(sprintf("IC 95%% bootstrap (ponderado): [%.4f, %.4f]\n", ci_boot[1], ci_boot[2]))
cat(sprintf("p-valor (permutación, bilateral): %.5f\n", p_perm))
cat("\n-- Aproximación analítica (rápida; usar solo como referencia) --\n")
cat(sprintf("IC 95%% analítico (n_eff=%.1f): [%.4f, %.4f]\n",
n_eff, ci_ana[1], ci_ana[2]))
cat(sprintf("p-valor analítico (normal aprox.): %.5f\n", p_norm))
# Paquetes ---------------------------------------------------------------
if (!requireNamespace("wCorr", quietly = TRUE)) install.packages("wCorr")
library(wCorr)
# --- ENTRADAS -----------------------------------------------------------
x <- cartagena$vulnerability_score
y <- cartagena$servicios
w <- cartagena$f_exp_hog
# Limpieza ---------------------------------------------------------------
keep <- is.finite(x) & is.finite(y) & is.finite(w) & w > 0
x <- x[keep]; y <- y[keep]; w <- w[keep]
w_prob <- w / sum(w)
n <- length(x)
# 1) Rho de Spearman ponderado (observado) -------------------------------
rho_obs <- wCorr::weightedCorr(x, y, method = "Spearman", weights = w)
# 2) IC 95% unilateral inferior (bootstrap ponderado) --------------------
boot_weighted_spearman <- function(x, y, w, w_prob, R = 2000, seed = 123){
if(!is.null(seed)) set.seed(seed)
n <- length(x)
boots <- replicate(R, {
idx <- sample.int(n, replace = TRUE, prob = w_prob)
wCorr::weightedCorr(x[idx], y[idx], method = "Spearman", weights = w[idx])
})
# Unilateral inferior al 95%: [q0.05, 1]
ci_lower <- as.numeric(stats::quantile(boots, 0.05, na.rm = TRUE))
list(boots = boots, ci_lower = ci_lower)
}
boot_res <- boot_weighted_spearman(x, y, w, w_prob, R = 2000, seed = 123)
ci95_lower_boot <- boot_res$ci_lower
# 3) p-valor unilateral (permutación a la derecha: H0: ρ ≤ 0, H1: ρ > 0) --
perm_pvalue_right <- function(x, y, w, R = 10000, seed = 456){
if(!is.null(seed)) set.seed(seed)
obs <- wCorr::weightedCorr(x, y, method = "Spearman", weights = w)
perms <- replicate(R, {
y_perm <- sample(y, replace = FALSE)
wCorr::weightedCorr(x, y_perm, method = "Spearman", weights = w)
})
# Proporción de permutaciones >= observado (cola derecha, corrección +1)
p_right <- (sum(perms >= obs) + 1) / (R + 1)
list(p_right = p_right, obs = obs)  # perms opcional si quieres inspeccionarlos
}
perm_res <- perm_pvalue_right(x, y, w, R = 10000, seed = 456)
p_perm_right <- perm_res$p_right
# 4) (Opcional) Aproximación analítica unilateral con n_eff --------------
#    Var(z_spearman) ≈ 1.06/(n_eff - 3)  (Bonett & Wright, 2000)
n_eff <- (sum(w)^2) / sum(w^2)
z_s  <- 0.5 * log((1 + rho_obs) / (1 - rho_obs))
se_z <- sqrt(1.06 / pmax(n_eff - 3, 1.0001))
zstat <- z_s / se_z
p_norm_right <- 1 - pnorm(zstat)                        # cola derecha
z_lower <- z_s - qnorm(0.95) * se_z                     # límite inferior 95%
ci95_lower_ana <- tanh(z_lower)                         # volver a rho
# Salida -----------------------------------------------------------------
cat("\n### C. Rho de Spearman Ponderado (Hipótesis unilateral: ρ > 0) ###\n\n")
cat(sprintf("Rho ponderado (observado): %.4f\n", rho_obs))
cat(sprintf("IC 95%% unilateral inferior (bootstrap): [%.4f, 1]\n", ci95_lower_boot))
cat(sprintf("p-valor (permutación, cola derecha): %.5f\n", p_perm_right))
cat("\n-- Aproximación analítica (referencia rápida) --\n")
cat(sprintf("n_eff = %.1f\n", n_eff))
cat(sprintf("Límite inferior 95%% analítico: [%.4f, 1]\n", ci95_lower_ana))
cat(sprintf("p-valor analítico (cola derecha): %.5f\n", p_norm_right))
# ------------------------------------------------------------------------
# C. CÁLCULO DE RHO DE SPEARMAN PONDERADO (SUPUESTOS A, C y D)
# ------------------------------------------------------------------------
cat("\n### C. Rho de Spearman Ponderado (Estadístico de Prueba) ###\n\n")
# Usamos weightedCorr para obtener el coeficiente ajustado por los pesos
resultado_spearman <- weightedCorr(
x = cartagena$vulnerability_score,
y = cartagena$servicios,
method = "Spearman",
weights = cartagena$f_exp_hog
)
cat(sprintf("Resultado del Rho de Spearman PONDERADO: %.4f\n", resultado_spearman))
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
kableExtra,
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr         # Generación de reportes dinámicos.
)
# Rutas y datos iniciales
xlsx_path <- "data/2025 JNA VP.xlsx"
hogares <- read_excel(xlsx_path, sheet = "Hogares") %>% clean_names()
# Instalar si es necesario
#install.packages(c("wCorr", "survey"))
# Cargar las librerías
library(dplyr)
library(wCorr)
# Instalar si es necesario
install.packages(c("wCorr", "survey"))
install.packages(c("wCorr", "survey"))
# Instalar si es necesario
install.packages(c("wCorr", "survey"))
# Cargar las librerías
library(dplyr)
library(wCorr)
library(survey)
library(knitr)
library(readr)
library(fs)
install.packages(c("wCorr", "survey"))
